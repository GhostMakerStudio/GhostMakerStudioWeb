<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin Panel - GhostMaker Studio</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Force ghost theme */
        body {
            background: linear-gradient(135deg, #0a0a0a, #1a1a1a) !important;
            color: #ffffff !important;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif !important;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            background: linear-gradient(135deg, #00d4aa, #8a2be2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 2.5rem;
            margin-bottom: 2rem;
            text-align: center;
        }
        
        .add-project-btn {
            background: linear-gradient(135deg, #00d4aa, #8a2be2);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            margin: 0 auto;
            display: block;
            transition: transform 0.3s ease;
        }
        
        .add-project-btn:hover {
            transform: scale(1.05);
        }

        /* Global Upload Progress Overlay */
        .upload-progress-overlay {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            min-width: 300px;
            z-index: 10000;
            display: none;
            backdrop-filter: blur(10px);
        }

        .upload-progress-overlay.visible {
            display: block;
        }

        .upload-progress-header {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .upload-progress-icon {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .upload-progress-title {
            font-weight: bold;
            color: #00ff88;
        }

        .upload-progress-stats {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 8px;
        }

        .upload-progress-bar {
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .upload-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        .upload-progress-details {
            font-size: 11px;
            color: #888;
            display: flex;
            justify-content: space-between;
        }
        
        .admin-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 2rem;
        }
        
        .reorder-btn {
            background: #444;
            border: 1px solid #00d4aa;
            color: #00d4aa;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .reorder-btn:hover {
            background: #00d4aa;
            color: #000;
        }
        
        .reorder-btn.active {
            background: #ff4444 !important;
            border-color: #ff4444 !important;
            color: white !important;
        }
        
        .project-delete-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            z-index: 10;
            transition: all 0.3s ease;
        }
        
        .project-delete-btn:hover {
            background: rgba(239, 68, 68, 1);
            transform: scale(1.1);
        }
        
        .projects-list.reorder-mode {
            border: 2px dashed #00d4aa;
            border-radius: 12px;
            padding: 20px;
            background: rgba(0, 212, 170, 0.05);
        }
        
        .project-card {
            position: relative;
            transition: all 0.3s ease;
        }
        
        .reorder-mode .project-card {
            cursor: move;
        }
        
        .project-card.dragging {
            opacity: 0.6;
            transform: rotate(3deg) scale(1.05);
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .project-card.drag-over {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
            transform: scale(1.02);
        }
        
        .project-card.dragging {
            opacity: 0.5;
            transform: rotate(3deg) scale(1.05);
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        .project-card.drag-above {
            border-left: 3px solid #00d4aa;
            margin-left: 10px;
        }
        
        .project-card.drag-below {
            border-right: 3px solid #00d4aa;
            margin-right: 10px;
        }
        
        .project-card.removed {
            display: none !important;
        }
        
        .drag-clone {
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
        }
        
        .drop-placeholder {
            width: 4px;
            height: 100%;
            background: #00d4aa;
            border-radius: 2px;
            opacity: 0.8;
            transition: all 0.3s ease;
            position: absolute;
            top: 0;
            z-index: 10;
        }
        
        .reorder-mode .project-card {
            cursor: move;
            transition: all 0.3s ease;
        }
        
        .reorder-mode .project-card:hover {
            transform: scale(1.02);
            border-color: #00d4aa;
        }
        
        /* Media Viewer Modal Styles */
        .media-viewer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .media-viewer-content {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
        }
        
        .media-viewer-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #444;
        }
        
        .media-viewer-header h3 {
            color: #00d4aa;
            margin: 0;
            font-size: 1.5rem;
        }
        
        .close-viewer {
            background: none;
            border: none;
            color: #888;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }
        
        .close-viewer:hover {
            color: #fff;
            background: #444;
        }
        
        .media-viewer-body {
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 8px;
            max-height: 70vh;
            overflow-y: auto;
            position: relative; /* Add this for proper absolute positioning of drop indicator */
        }
        
        .media-item {
            border-radius: 6px;
            overflow: hidden;
            background: #1a1a1a;
            border: 1px solid #333;
            aspect-ratio: 1;
            cursor: grab;
            transition: all 0.2s ease;
            position: relative;
            user-select: none;
            transform: translate(0, 0);
            z-index: 1;
        }
        
        .media-item:hover {
            border-color: #00d4aa;
            transform: scale(1.05);
            z-index: 10;
            box-shadow: 0 4px 20px rgba(0, 212, 170, 0.3);
        }
        
        /* Disable hover effects when in reorder mode */
        .reorder-mode .media-item:hover {
            border-color: #333 !important; /* Keep original border */
            transform: none !important; /* No zoom effect */
            z-index: 1 !important; /* Reset z-index */
            box-shadow: none !important; /* No glow effect */
        }
        
        .media-item.dragging {
            opacity: 0.9;
            transform: rotate(5deg) scale(1.1);
            z-index: 999;
            cursor: grabbing;
            transition: none;
        }
        
        .media-item.shifting {
            /* Remove visual effects - just keep minimal z-index */
            z-index: 2;
        }
        
        .media-item.drag-over {
            /* Remove border and zoom effects - keep minimal visual feedback */
            border-color: #00d4aa;
            border-width: 1px;
        }
        
        .drop-indicator {
            position: absolute;
            background: #00d4aa;
            border-radius: 2px;
            z-index: 999;
            transition: all 0.2s ease;
            box-shadow: 0 0 15px rgba(0, 212, 170, 0.8);
            pointer-events: none;
        }
        
        .drop-indicator.vertical {
            width: 3px;
            height: 100%;
            top: 0;
            background: #00d4aa;
            box-shadow: 0 0 10px rgba(0, 212, 170, 0.9);
        }
        
        .media-item.dragged {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            transform: rotate(5deg) scale(0.4); /* Much smaller - 40% of original size */
            opacity: 0.8;
            transition: none;
        }
        
        .drop-indicator-line {
            position: absolute;
            width: 3px;
            background: #00d4aa;
            border-radius: 2px;
            z-index: 999;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(0, 212, 170, 0.8);
            animation: indicatorPulse 1.5s ease-in-out infinite;
        }
        
        @keyframes indicatorPulse {
            0%, 100% { 
                opacity: 0.7;
                transform: scaleY(1);
            }
            50% { 
                opacity: 1;
                transform: scaleY(1.05);
            }
        }
        
        .media-item.removed {
            display: none !important;
        }
        
        /* Prevent hover effects during drag operations */
        .media-viewer-modal.dragging .media-item:not(.removed) {
            pointer-events: none;
        }
        
        .media-viewer-modal.dragging .media-item:not(.removed):hover {
            transform: none !important;
            box-shadow: none !important;
        }
        
        
        .reorder-mode {
            background: rgba(0, 212, 170, 0.1) !important;
            border: 2px dashed #00d4aa !important;
        }
        
        .reorder-mode .media-item {
            cursor: grab !important;
        }
        
        .reorder-mode .media-item:hover {
            cursor: grabbing !important;
            /* Visual effects disabled above */
        }
        
        .delete-btn {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .delete-btn:hover {
            background: rgba(220, 53, 69, 1);
            transform: scale(1.1);
        }
        
        .reorder-mode .delete-btn {
            display: flex;
        }
        
        .delete-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .delete-drop-zone {
            width: 100px;
            height: 60px;
            background: rgba(255, 68, 68, 0.1);
            border: 2px dashed #ff4444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            pointer-events: auto;
            user-select: none;
        }
        
        .delete-drop-zone:not(.visible) {
            display: none !important;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            cursor: default;
        }
        
        .delete-all-btn {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 4px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        .delete-all-btn:hover {
            background: #ff2222;
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(255, 68, 68, 0.3);
        }
        
        .delete-all-btn:active {
            transform: scale(0.95);
        }
        
        .delete-drop-zone.drag-over {
            background: rgba(255, 68, 68, 0.3);
            border-color: #ff2222;
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 68, 68, 0.5);
        }
        
        .delete-icon {
            font-size: 20px;
            margin-bottom: 2px;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .delete-text {
            font-size: 10px;
            color: #ff4444;
            text-align: center;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
        }
        
        
        
        .reorder-toggle {
            background: #00d4aa;
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }
        
        .reorder-toggle:hover {
            background: #00b894;
            transform: translateY(-2px);
        }
        
        .reorder-toggle.active {
            background: #e74c3c;
            color: white;
        }
        
        .reorder-toggle.active:hover {
            background: #c0392b;
        }
        
        .media-item img,
        .media-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transition: opacity 0.3s ease;
        }
        
        .media-slide {
            object-fit: contain !important;
        }
        
        .media-item img[data-original] {
            opacity: 0.8;
        }
        
        .media-item img[data-original]:hover {
            opacity: 1;
        }
        
        /* Loading state for images */
        .media-item img:not([src]) {
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: loading 1.5s infinite;
        }
        
        @keyframes loading {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }
        
        .media-item .play-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
        }
        
        .media-item:hover .play-icon {
            transform: translate(-50%, -50%) scale(1.1);
            background: rgba(0, 184, 148, 0.9);
        }
        
        /* Quality selection is now automatic - no manual controls needed */
        
        .no-media {
            grid-column: 1 / -1;
            text-align: center;
            color: #888;
            padding: 40px;
            font-size: 1.1rem;
        }
        
        /* Fullscreen Modal Styles */
        /* Big, predictable viewer box */
        .fullscreen-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex; 
            align-items: center; 
            justify-content: center;
            padding: 2vw; /* breathing room on small screens */
            z-index: 2000;
        }

        .fullscreen-content {
            width: min(95vw, 1600px);  /* Much bigger like the red one */
            aspect-ratio: 16 / 9;   /* keeps 16:9 without manual height */
            height: auto;           /* aspect-ratio drives height */
            display: flex;          /* ensure children can stretch */
            align-items: center; 
            justify-content: center;
            position: relative;     /* Ensure arrows can position relative to this */
        }
        
        .close-fullscreen {
            position: absolute;
            top: -50px;
            right: 0;
            background: #8a2be2;
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .close-fullscreen:hover {
            background: #00d4aa;
            transform: scale(1.1);
        }
        
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: none;
            color: white;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .nav-arrow:hover {
            background: rgba(0, 212, 170, 0.8);
            transform: translateY(-50%) scale(1.1);
        }
        
        .nav-arrow.prev {
            left: 20px;
        }
        
        .nav-arrow.next {
            right: 20px;
        }
        
        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .nav-arrow:disabled:hover {
            background: rgba(0, 0, 0, 0.7);
            transform: translateY(-50%);
        }
        
        .media-counter {
            position: absolute;
            top: -50px;
            left: 0;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 10;
        }
        
        /* Video fills the box but never distorts */
        .fullscreen-content img,
        .fullscreen-content video {
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            width: 100%;
            height: 100%;
            object-fit: contain;
            max-width: none; 
            max-height: none;
            transition: none !important;  /* prevent size changes during quality switches */
        }
        
        /* CSS aspect-ratio handles responsive sizing automatically */
        
        /* Project Card Cursor */
        .project-card {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .project-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 212, 170, 0.2);
        }
        
        .project-form {
            background: #1a1a1a;
            border: 2px solid #00d4aa;
            border-radius: 12px;
            padding: 30px;
            margin-top: 30px;
            display: none;
        }
        
        .project-form.show {
            display: block;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #00d4aa;
            font-weight: 500;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: white;
            font-size: 1rem;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #00d4aa;
            box-shadow: 0 0 10px rgba(0, 212, 170, 0.3);
        }
        
        textarea {
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 6px;
            color: white;
            font-size: 1rem;
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
        }
        
        textarea:focus {
            outline: none;
            border-color: #00d4aa;
            box-shadow: 0 0 10px rgba(0, 212, 170, 0.3);
        }
        
        .upload-area {
            border: 2px dashed #666;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            background: #2a2a2a;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area.drag-over {
            border-color: #00d4aa;
            background: rgba(0, 212, 170, 0.1);
        }
        
        .upload-area p {
            margin: 0;
            color: #ccc;
            font-size: 1.1rem;
        }
        
        .upload-area small {
            color: #888;
            display: block;
            margin-top: 10px;
        }
        
        .uploaded-file {
            background: #2a2a2a;
            border: 1px solid #00d4aa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }
        
        .uploaded-file.show {
            display: block;
        }
        
        .uploaded-file img,
        .uploaded-file video {
            max-width: 200px;
            max-height: 150px;
            border-radius: 6px;
        }
        
        .save-btn {
            background: #00d4aa;
            border: none;
            color: white;
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 20px;
        }
        
        .save-btn:hover {
            background: #00b894;
        }
        
        .cancel-btn {
            background: #666;
            border: none;
            color: white;
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 6px;
            cursor: pointer;
            margin-top: 20px;
            margin-left: 10px;
        }
        
        .cancel-btn:hover {
            background: #777;
        }
        
        /* Live Preview Section - Full Width Like Main Page */
        .live-preview-section {
            background: transparent;
            border: none;
            padding: 0;
            margin: 0 -50px 30px -50px; /* Break out of admin container */
            width: calc(100% + 100px); /* Extend beyond container */
        }
        
        .live-preview-section h2 {
            color: #ff6b6b;
            margin-bottom: 20px;
            text-align: center;
            padding: 0 50px; /* Add padding back for the title */
        }
        
        /* Main Page Portfolio Styles - Exact Copy */
        .portfolio-grid {
            display: grid;
            gap: 20px;
            justify-content: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .portfolio-item {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .portfolio-item:hover {
            border-color: #00d4aa;
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 212, 170, 0.2);
        }
        
        .portfolio-cover {
            width: 100%;
            height: 150px;
            background: #1a1a1a;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .portfolio-cover img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transition: transform 0.3s ease;
        }
        
        .portfolio-item:hover .portfolio-cover img {
            transform: scale(1.05);
        }
        
        .portfolio-item h3 {
            color: #00d4aa;
            margin: 0 0 10px 0;
            font-size: 1.3rem;
        }
        
        .portfolio-item p {
            color: #ccc;
            margin: 0 0 15px 0;
            font-size: 0.9rem;
        }
        
        .portfolio-stats {
            color: #ccc;
            font-size: 0.9rem;
            margin: 0;
        }

        /* Admin Tabs */
        .admin-tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
        }
        
        .tab-button {
            background: #2a2a2a;
            border: none;
            color: #888;
            padding: 15px 30px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            margin-right: 5px;
        }
        
        .tab-button:hover {
            background: #333;
            color: #ccc;
        }
        
        .tab-button.active {
            background: #1a1a1a;
            color: #00d4aa;
            border-bottom-color: #00d4aa;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        /* Projects Gallery */
        .projects-gallery {
            margin-top: 40px;
        }
        
        .projects-gallery h2 {
            color: #00d4aa;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .projects-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .project-card {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .project-card:hover {
            border-color: #00d4aa;
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 212, 170, 0.2);
        }
        
        /* Upload indicators */
        /* Upload indicators removed - using global overlay now */
        
        /* Drag and drop styling */
        .project-card.drag-over {
            border: 2px dashed #00d4aa !important;
            background: rgba(0, 212, 170, 0.1) !important;
            transform: scale(1.05) !important;
        }
        
        .project-card.drag-over::after {
            content: "Drop files here";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 212, 170, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            z-index: 100;
            pointer-events: none;
        }
        
        .project-card h3 {
            color: #00d4aa;
            margin: 0 0 10px 0;
            font-size: 1.3rem;
        }
        
        .project-card p {
            color: #ccc;
            margin: 0 0 15px 0;
            font-size: 0.9rem;
        }
        
        .project-cover {
            width: 100%;
            height: 150px;
            background: #1a1a1a;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .project-cover img,
        .project-cover video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .project-stats {
            color: #888;
            font-size: 0.8rem;
            margin-bottom: 15px;
        }
        
        .project-actions {
            display: flex;
            gap: 10px;
        }
        
        .project-actions button {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }
        
        
        .edit-btn {
            background: #00d4aa;
            color: white;
        }
        
        .edit-btn:hover {
            background: #00b894;
        }
        
        .delete-btn {
            background: #ff4757;
            color: white;
        }
        
        .delete-btn:hover {
            background: #ff3742;
        }
        
        .project-delete-btn {
            background: #ff4757;
            color: white;
        }
        
        .project-delete-btn:hover {
            background: #ff3742;
        }
        
        .no-projects {
            text-align: center;
            color: #888;
            font-style: italic;
            padding: 40px;
        }
        
        /* Project creation loading overlay */
        .project-loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            color: white;
        }
        
        .project-loading-overlay .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #00b894;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        .project-loading-overlay .message {
            font-size: 18px;
            font-weight: 500;
            text-align: center;
        }
        
        .project-loading-overlay .sub-message {
            font-size: 14px;
            color: #ccc;
            margin-top: 10px;
            text-align: center;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Disable interactions during project creation */
        .creating-project .project-card {
            pointer-events: none;
            opacity: 0.6;
        }
        
        .creating-project .add-project-btn {
            pointer-events: none;
            opacity: 0.6;
        }
        
        /* Grid Layout Editor Styles */
        .grid-settings {
            background: #1a1a1a;
            border: 2px solid #00d4aa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .grid-settings h3 {
            color: #00d4aa;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .grid-controls {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .grid-controls label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ccc;
            font-weight: 500;
        }
        
        .grid-controls input[type="number"] {
            width: 60px;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: white;
            text-align: center;
        }
        
        .apply-grid-btn {
            background: #00d4aa;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }
        
        .apply-grid-btn:hover {
            background: #00b894;
            transform: translateY(-2px);
        }
        
        .grid-preview {
            margin-bottom: 30px;
        }
        
        .grid-container {
            display: grid;
            gap: 10px;
            justify-content: center;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .grid-position {
            width: 120px;
            height: 120px;
            background: #2a2a2a;
            border: 2px dashed #666;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            min-height: 120px;
        }
        
        .grid-position:hover {
            border-color: #00d4aa;
            background: rgba(0, 212, 170, 0.1);
        }
        
        .grid-position.occupied {
            border: 2px solid #00d4aa;
            background: #1a1a1a;
            cursor: grab;
        }
        
        .grid-position.occupied:hover {
            transform: scale(1.05);
        }
        
        .grid-position.drag-over {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            transform: scale(1.02);
        }
        
        .grid-position-number {
            position: absolute;
            top: 4px;
            left: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: #888;
            font-size: 10px;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
        
        .project-in-grid {
            width: 100%;
            height: 100%;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }
        
        .project-in-grid img,
        .project-in-grid video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .project-in-grid .project-title {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            color: white;
            padding: 8px 4px 4px;
            font-size: 10px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .remove-from-grid {
            position: absolute;
            top: 2px;
            right: 2px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .project-in-grid:hover .remove-from-grid {
            opacity: 1;
        }
        
        .unused-projects-bin {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 20px;
        }
        
        .unused-projects-bin h4 {
            color: #00d4aa;
            margin: 0 0 15px 0;
            text-align: center;
        }
        
        .projects-bin {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        .unused-project {
            width: 80px;
            height: 80px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .unused-project:hover {
            border-color: #00d4aa;
            transform: scale(1.05);
        }
        
        .unused-project.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        
        .unused-project img,
        .unused-project video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .unused-project .project-title {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            color: white;
            padding: 4px 2px 2px;
            font-size: 8px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Current Grid Display */
        .current-grid-display {
            background: #1a1a1a;
            border: 2px solid #00d4aa;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .current-grid-display h2 {
            color: #00d4aa;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .current-grid-container {
            display: grid;
            gap: 15px;
            justify-content: center;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .current-grid-item {
            width: 150px;
            height: 150px;
            background: #2a2a2a;
            border: 2px solid #00d4aa;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }
        
        .current-grid-item img,
        .current-grid-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .current-grid-item .project-title {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            color: white;
            padding: 8px;
            font-size: 12px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .current-grid-empty {
            background: #333;
            border: 2px dashed #666;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            font-size: 12px;
        }
        
        /* Admin Separator */
        .admin-separator {
            margin: 40px 0;
            text-align: center;
        }
        
        .admin-separator hr {
            border: none;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00d4aa, transparent);
            margin: 20px 0;
        }
        
        .admin-separator h3 {
            color: #00d4aa;
            margin: 0;
            font-size: 1.5rem;
        }
        
        /* üéØ PROCESSING INDICATORS - Facebook/Instagram style */
        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            border-radius: 8px;
            backdrop-filter: blur(4px);
        }
        
        .processing-content {
            text-align: center;
            color: white;
            padding: 20px;
        }
        
        .processing-spinner {
            margin-bottom: 15px;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .processing-text {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
            color: #00ff88;
        }
        
        .processing-subtext {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .processing-content.success {
            animation: successPulse 0.6s ease-out;
        }
        
        @keyframes successPulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .success-checkmark {
            margin-bottom: 15px;
        }
        
        .checkmark {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #00ff88;
            position: relative;
            margin: 0 auto;
            animation: checkmarkBounce 0.6s ease-out;
        }
        
        .checkmark::after {
            content: '';
            position: absolute;
            left: 12px;
            top: 20px;
            width: 8px;
            height: 16px;
            border: solid white;
            border-width: 0 3px 3px 0;
            transform: rotate(45deg);
        }
        
        @keyframes checkmarkBounce {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body>
    <!-- Global Upload Progress Overlay -->
    <div class="upload-progress-overlay" id="uploadProgressOverlay">
        <div class="upload-progress-header">
            <div class="upload-progress-icon">üì§</div>
            <div class="upload-progress-title">Uploading Files</div>
        </div>
        <div class="upload-progress-stats" id="uploadProgressStats">
            File 0 of 0
        </div>
        <div class="upload-progress-bar">
            <div class="upload-progress-fill" id="uploadProgressFill" style="width: 0%"></div>
        </div>
        <div class="upload-progress-details">
            <span id="uploadProgressSize">0 MB / 0 MB</span>
            <span id="uploadProgressQueue">Queue: 0</span>
        </div>
    </div>

    <div class="container">
        <h1>GhostMaker Studio Admin</h1>
        
        <!-- Tab Navigation -->
        <div class="admin-tabs">
            <button id="projectsTab" class="tab-button active" onclick="switchTab('projects')">
                üìÅ Project Management
            </button>
            <button id="gridTab" class="tab-button" onclick="switchTab('grid')">
                üéØ Grid Layout Editor
            </button>
        </div>
        
        <!-- Projects Tab Content -->
        <div id="projectsTabContent" class="tab-content active">
            <div class="admin-actions">
        <button id="addProjectBtn" class="add-project-btn">+ Add New Project</button>
            </div>
        
        <!-- Projects Gallery -->
        <div id="projectsGallery" class="projects-gallery">
            <h2>Your Projects</h2>
            <div id="projectsList" class="projects-list">
                <!-- Projects will be loaded here -->
            </div>
            </div>
        
        </div>
        
        <!-- Grid Layout Tab Content -->
        <div id="gridTabContent" class="tab-content">
            <!-- Grid Layout Settings -->
            <div id="gridSettings" class="grid-settings">
            <h3>Customize Grid Layout</h3>
            <div class="grid-controls">
                <label>Section Title: <input type="text" id="sectionTitle" value="Our Work" placeholder="Enter section title">
                <button id="saveTitleBtn" class="save-title-btn" title="Save title changes" style="background: #27ae60; color: white; border: none; padding: 5px 10px; border-radius: 4px; margin-left: 5px; cursor: pointer;">üíæ</button></label>
                <label>Grid Width: <input type="number" id="gridWidth" value="4" min="1" max="10"></label>
                <label>Grid Height: <input type="number" id="gridHeight" value="5" min="1" max="20"></label>
                <button id="applyGridBtn" class="apply-grid-btn">Apply Grid</button>
                <button onclick="saveGridLayout()" class="apply-grid-btn" style="background: #3498db; margin-left: 10px;">üíæ Save Grid Layout</button>
            </div>
            <div class="grid-preview">
                <div id="gridContainer" class="grid-container">
                    <!-- Grid positions will be generated here -->
                </div>
            </div>
            <div class="unused-projects-bin">
                <h4>Unused Projects</h4>
                <div id="unusedProjectsBin" class="projects-bin">
                    <!-- Projects not in grid will appear here -->
                </div>
            </div>
        </div>
        
        <!-- Live Preview Section -->
        <div id="livePreview" class="live-preview-section">
            <h2>üéØ Live Preview - How It Looks on Main Page</h2>
        </div>
        
        </div>
        
        <div id="projectForm" class="project-form">
            <div class="form-group">
                <label for="projectTitle">Project Title</label>
                <input type="text" id="projectTitle" placeholder="Enter project title">
            </div>
            
            <div class="form-group">
                <label for="projectDescription">Project Description</label>
                <textarea id="projectDescription" placeholder="Enter project description" rows="4"></textarea>
            </div>
            
            <button id="saveBtn" class="save-btn">Create Project</button>
            <button id="cancelBtn" class="cancel-btn">Cancel</button>
        </div>
    </div>

    <link rel="preconnect" href="https://d17lfecj9hzae.cloudfront.net">
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        console.log('üé¨ Admin dashboard script loaded - v2.1 (fixed quality selection)');
        let uploadedFileData = null;
        let projects = [];
        let isReorderMode = false;
        let isProjectReorderMode = false;
        let isGridEditMode = false;
        let gridLayout = { width: 4, height: 5, positions: {} };
        let isCreatingProject = false;
        
        // Local state management for better performance
        let localProjectState = null; // Keep a local copy of the current project
        let pendingPositionUpdates = []; // Queue of position updates to sync
        let syncInProgress = false; // Prevent multiple syncs
        
        // Initialize local project state
        function initializeLocalProjectState(project) {
            localProjectState = {
                id: project.id,
                content: [...project.content] // Deep copy of content array
            };
            console.log('üîÑ Initialized local project state with', localProjectState.content.length, 'items');
        }
        
        // Update local state immediately (no backend call)
        function updateLocalPositions(draggedIndex, targetIndex) {
            if (!localProjectState) return;
            
            console.log('üîÑ Updating local positions: draggedIndex =', draggedIndex, 'targetIndex =', targetIndex);
            console.log('üìã Before update:', localProjectState.content.map((item, idx) => `${idx}: ${item.alt || item.url.split('/').pop()}`));
            
            const newContent = [...localProjectState.content];
            const draggedItem = newContent.splice(draggedIndex, 1)[0];
            newContent.splice(targetIndex, 0, draggedItem);
            
            localProjectState.content = newContent;
            
            console.log('üìã After update:', localProjectState.content.map((item, idx) => `${idx}: ${item.alt || item.url.split('/').pop()}`));
            
            // Update data-index attributes for all items
            const viewerBody = document.getElementById('mediaViewerBody');
            if (viewerBody) {
                Array.from(viewerBody.children).forEach((item, idx) => {
                    item.setAttribute('data-index', idx);
                });
            }
            
            console.log('‚úÖ Local positions updated instantly');
        }
        
        // Queue position update for background sync
        function queuePositionUpdate(projectId, newContent) {
            pendingPositionUpdates.push({
                projectId: projectId,
                content: newContent,
                timestamp: Date.now()
            });
            
            // Start background sync if not already running
            if (!syncInProgress) {
                setTimeout(syncPositionUpdates, 100); // Small delay to batch updates
            }
        }
        
        // Background sync of position updates
        async function syncPositionUpdates() {
            if (syncInProgress || pendingPositionUpdates.length === 0) return;
            
            syncInProgress = true;
            console.log('üîÑ Starting background sync of', pendingPositionUpdates.length, 'updates');
            
            try {
                // Get the most recent update for each project
                const latestUpdates = {};
                pendingPositionUpdates.forEach(update => {
                    if (!latestUpdates[update.projectId] || update.timestamp > latestUpdates[update.projectId].timestamp) {
                        latestUpdates[update.projectId] = update;
                    }
                });
                
                // Sync each project
                for (const [projectId, update] of Object.entries(latestUpdates)) {
                    await saveMediaOrderSilently(projectId, update.content);
                }
                
                console.log('‚úÖ Background sync completed successfully');
            } catch (error) {
                console.error('‚ùå Background sync failed:', error);
            } finally {
                syncInProgress = false;
                pendingPositionUpdates = []; // Clear the queue
            }
        }
        
        // Silent save (no UI updates, no reloads)
        async function saveMediaOrderSilently(projectId, newContent) {
            try {
                const response = await fetch(`/api/projects/${projectId}/media-order`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        mediaOrder: newContent.map((item, index) => ({
                            mediaId: item.mediaId,
                            position: index
                        }))
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                console.log('‚úÖ Position synced silently to backend');
                
                // Refresh projects to update cover image display after reordering
                setTimeout(async () => {
                    console.log('üîÑ Refreshing projects to update cover image after reorder...');
                    await loadProjects();
                }, 500);
            } catch (error) {
                console.error('‚ùå Silent sync failed:', error);
                throw error;
            }
        }
        
        // Image caching system
        let imageCache = new Map();
        const CACHE_SIZE_LIMIT = 200; // Max cached images (increased for aggressive preloading)
        
        // Preloading system
        let preloadQueue = new Set(); // Track what's being preloaded
        const preloadRadius = 2; // Load only 2 images ahead and behind (reduced for performance)
        
        // Image caching functions
        function cacheImage(url, element) {
            if (imageCache.has(url)) {
                return imageCache.get(url);
            }
            
            // Limit cache size
            if (imageCache.size >= CACHE_SIZE_LIMIT) {
                const firstKey = imageCache.keys().next().value;
                imageCache.delete(firstKey);
            }
            
            imageCache.set(url, element.cloneNode(true));
            return element;
        }
        
        function getCachedImage(url) {
            return imageCache.get(url) || null;
        }
        
        function preloadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    cacheImage(url, img);
                    resolve(img);
                };
                img.onerror = reject;
                img.src = url;
            });
        }
        
        // Smart video quality selection - ALWAYS starts with lowest quality for instant playback
        function selectVideoQuality(videoQualities, mode = 'lowest') {
            if (!videoQualities || videoQualities.length === 0) {
                return null;
            }
            
            // Filter out qualities higher than 1080p (no 4K)
            const filteredQualities = videoQualities.filter(q => {
                // Keep qualities that are NOT 4K, 2160p, or higher
                const is4K = q.quality === '4K' || q.quality === '2160p' || q.resolution === '2160p' || q.resolution === '4K';
                return !is4K;
            });
            
            if (filteredQualities.length === 0) {
                console.log('‚ö†Ô∏è All qualities are 4K+, using first available');
                return videoQualities[0];
            }
            
            if (mode === 'lowest') {
                // Start with 480p if available (good balance of speed and quality)
                const quality480p = filteredQualities.find(q => q.quality === '480p');
                if (quality480p) {
                    console.log('üé¨ Starting with 480p for fast loading and good visual quality');
                    return quality480p;
                }
                // Fallback to 720p if no 480p
                const quality720p = filteredQualities.find(q => q.quality === '720p');
                if (quality720p) {
                    console.log('üé¨ Starting with 720p (no 480p available)');
                    return quality720p;
                }
                // Fallback to first available
                return filteredQualities[0];
            } else if (mode === 'next') {
                // For upgrades - used by adaptive streaming
                return filteredQualities;
            }
            
            // Legacy mode: Get connection speed estimate (kept for backwards compatibility)
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            
            if (connection) {
                const effectiveType = connection.effectiveType;
                const downlink = connection.downlink; // Mbps
                
                console.log('üåê Connection info:', { effectiveType, downlink });
                
                // Select quality based on connection (capped at 1080p)
                if (effectiveType === 'slow-2g' || downlink < 0.5) {
                    return filteredQualities.find(q => q.quality === 'low') || filteredQualities[0];
                } else if (effectiveType === '2g' || downlink < 1) {
                    return filteredQualities.find(q => q.quality === 'medium') || filteredQualities[0];
                } else if (effectiveType === '3g' || downlink < 2) {
                    return filteredQualities.find(q => q.quality === 'high') || filteredQualities[0];
                } else {
                    // Fast connection - use best available quality (up to 1080p)
                    return filteredQualities[filteredQualities.length - 1];
                }
            } else {
                // Fallback - use medium quality for better performance
                return filteredQualities.find(q => q.quality === 'medium') || filteredQualities[0];
            }
        }
        
        // Simple TikTok-style: start with best quality based on connection, no switching
        let activeAdaptiveStreams = new Map();
        
        function startAdaptiveVideoStreaming(video, mediaIndex, videoQualities) {
            if (!video || !videoQualities || videoQualities.length <= 1) {
                console.log('‚ö†Ô∏è Adaptive streaming not needed (single quality or no video)');
                return;
            }
            
            // Filter out 4K and higher qualities, and skip visually small versions
            const availableQualities = videoQualities.filter(q => {
                const is4K = q.quality === '4K' || q.quality === '2160p' || q.resolution === '2160p' || q.resolution === '4K';
                if (is4K) return false;
                
                // Skip only the very small versions that cause visual glitches
                const isTooSmall = q.quality === '240p' || q.quality === '360p' || 
                                 q.resolution === '240p' || q.resolution === '360p';
                if (isTooSmall) return false;
                
                return true;
            }).sort((a, b) => {
                // Sort by resolution priority: 480p -> 720p -> 1080p -> original -> high -> medium -> low
                const order = { 
                    '480p': 1,
                    '720p': 2, 
                    '1080p': 3, 
                    'original': 4, 
                    'high': 5, 
                    'medium': 6, 
                    'low': 7 
                };
                return (order[a.quality] || 10) - (order[b.quality] || 10);
            });
            
            if (availableQualities.length <= 1) {
                console.log('‚ö†Ô∏è Only one quality available after filtering, no adaptive streaming needed');
                return;
            }
            
            console.log(`üé¨ Starting TikTok-style quality selection for video ${mediaIndex} with ${availableQualities.length} qualities (capped at 1080p)`);
            console.log(`üé¨ Available qualities in order:`, availableQualities.map(q => q.quality));
            
                // Simple approach: Start with best quality based on connection, no switching
            // This prevents all audio cuts and black screens
            let selectedQualityIndex = 0; // Default to 480p
            
            // Get connection speed and select appropriate starting quality
            const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
            
            if (connection) {
                const effectiveType = connection.effectiveType;
                const downlink = connection.downlink;
                
                console.log('üåê Connection info:', { effectiveType, downlink });
                
                // Conservative quality selection to avoid rendering walls
                if (effectiveType === '4g' && downlink > 8) {
                    selectedQualityIndex = Math.min(2, availableQualities.length - 1); // 1080p
                    console.log(`üöÄ Very fast connection (${downlink}Mbps), starting with ${availableQualities[selectedQualityIndex].quality}`);
                } else if (effectiveType === '4g' && downlink > 4) {
                    selectedQualityIndex = Math.min(1, availableQualities.length - 1); // 720p
                    console.log(`üì∂ Fast connection (${downlink}Mbps), starting with ${availableQualities[selectedQualityIndex].quality}`);
                } else {
                    selectedQualityIndex = 0; // 480p
                    console.log(`üêå Conservative connection (${downlink}Mbps), starting with ${availableQualities[selectedQualityIndex].quality}`);
                }
            } else {
                console.log('üåê No connection info, defaulting to 480p for safety');
            }
            
            // Switch to selected quality if different from current
            if (selectedQualityIndex > 0) {
                const selectedQuality = availableQualities[selectedQualityIndex];
                console.log(`üé¨ Starting with ${selectedQuality.quality} quality`);
                
                // Update video source to selected quality
                video.src = selectedQuality.url;
                
                // Update UI to reflect selected quality
                updateQualityUI(mediaIndex, selectedQuality.quality);
            }
            
            // Store stream state (no automatic switching)
            const streamState = {
                video,
                mediaIndex,
                availableQualities,
                selectedQualityIndex
            };
            activeAdaptiveStreams.set(mediaIndex, streamState);
            
            console.log(`‚úÖ Video ${mediaIndex} ready with ${availableQualities[selectedQualityIndex].quality} quality - no automatic switching to prevent audio cuts`);
            
            // Cleanup function
            const cleanup = () => {
                console.log(`üßπ Cleaning up video streaming for video ${mediaIndex}`);
                activeAdaptiveStreams.delete(mediaIndex);
            };
            
            // Clean up when video ends or is removed
            video.addEventListener('ended', cleanup);
            video.addEventListener('error', cleanup);
        }
        
        
        // Ultra-silent UI updates - no DOM manipulation that could cause glitches
        function updateQualityUI(mediaIndex, newQuality) {
            // Use a much longer delay to ensure video switching is completely done
            setTimeout(() => {
                // Update quality selector silently
                const selector = document.querySelector(`.video-quality-selector`);
                if (selector) {
                    selector.value = newQuality;
                    console.log(`üé¨ Updated quality selector to: ${newQuality}`);
                }
                
                // Update visual quality indicator with absolutely minimal impact
                const indicator = document.getElementById(`quality-indicator-${mediaIndex}`);
                if (indicator) {
                    // Use textContent instead of innerHTML to avoid any parsing
                    indicator.textContent = newQuality.toUpperCase();
                    console.log(`üé¨ Updated quality indicator to: ${newQuality.toUpperCase()}`);
                }
            }, 500); // Wait 500ms after video switch to update UI
        }
        
        // Seamlessly upgrade video quality without interrupting playback
        function upgradeVideoQuality(video, newQuality, mediaIndex, onComplete) {
            if (!video || !newQuality) return;
            
            const currentTime = video.currentTime;
            const wasPlaying = !video.paused;
            
            console.log(`üîÑ Seamlessly upgrading video to ${newQuality.quality} at ${currentTime.toFixed(2)}s`);
            
            // Change source and resume
            video.src = newQuality.url;
            video.currentTime = currentTime;
            
            if (wasPlaying) {
                video.play().catch(err => {
                    console.log('‚ö†Ô∏è Could not auto-resume after quality upgrade:', err);
                });
            }
            
            if (onComplete) {
                onComplete();
            }
        }
        
        // Smart image quality selection with modern format support and caching
        function selectImageQuality(imageQualities, skipBlur = false) {
            if (!imageQualities || imageQualities.length === 0) {
                return null;
            }
            
            // Sanitize and filter out invalid entries
            imageQualities = imageQualities.filter(q => q && q.quality);
            
            // When skipBlur is true, explicitly exclude blur placeholder
            if (skipBlur) {
                imageQualities = imageQualities.filter(q => q.quality !== 'blur_placeholder');
            }
            
            console.log('üîç selectImageQuality called with skipBlur:', skipBlur);
            console.log('üîç Available image qualities:', imageQualities.map(q => ({ quality: q.quality, resolution: q.resolution, formats: q.formats ? Object.keys(q.formats) : 'none' })));
            
            // If we're skipping blur (for cached images or progressive upgrade), go straight to high quality
            if (skipBlur) {
                console.log('üîç Looking for high quality images (skipBlur=true)');
                
                // Debug: Show all available qualities
                console.log('üîç All available qualities:', imageQualities.map(q => ({ quality: q.quality, resolution: q.resolution, url: q.url })));
                
                // Look for 1920w with modern formats first (highest quality)
                const quality1920w = imageQualities.find(q => q.resolution === '1920w');
                console.log('üîç 1920w quality found:', quality1920w ? 'YES' : 'NO');
                if (quality1920w) {
                    console.log('üîç 1920w quality details:', { quality: quality1920w.quality, hasFormats: !!quality1920w.formats, url: quality1920w.url });
                    if (quality1920w.formats) {
                        // Prefer HEIF, then WebP, then JPEG
                        const bestFormat = quality1920w.formats.heif || quality1920w.formats.webp || quality1920w.formats.jpg;
                        console.log('üîç Best format found:', bestFormat ? 'YES' : 'NO', bestFormat ? Object.keys(quality1920w.formats).find(f => quality1920w.formats[f] === bestFormat) : 'none');
                        if (bestFormat) {
                            console.log('‚úÖ Using 1920w quality with modern format:', Object.keys(quality1920w.formats).find(f => quality1920w.formats[f] === bestFormat));
                            return { ...quality1920w, url: bestFormat };
                        }
                    }
                    console.log('‚úÖ Using 1920w quality:', quality1920w.url);
                    return quality1920w;
                }
                
                // Fallback to 1280w with modern formats
                const quality1280w = imageQualities.find(q => q.resolution === '1280w');
                if (quality1280w) {
                    if (quality1280w.formats) {
                        const bestFormat = quality1280w.formats.heif || quality1280w.formats.webp || quality1280w.formats.jpg;
                        if (bestFormat) {
                            console.log('‚úÖ Using 1280w quality with modern format:', Object.keys(quality1280w.formats).find(f => quality1280w.formats[f] === bestFormat));
                            return { ...quality1280w, url: bestFormat };
                        }
                    }
                    console.log('‚úÖ Using 1280w quality:', quality1280w.url);
                    return quality1280w;
                }
                
                // Fallback to 960w with modern formats
                const quality960w = imageQualities.find(q => q.resolution === '960w');
                if (quality960w) {
                    if (quality960w.formats) {
                        const bestFormat = quality960w.formats.heif || quality960w.formats.webp || quality960w.formats.jpg;
                        if (bestFormat) {
                            console.log('‚úÖ Using 960w quality with modern format:', Object.keys(quality960w.formats).find(f => quality960w.formats[f] === bestFormat));
                            return { ...quality960w, url: bestFormat };
                        }
                    }
                    console.log('‚úÖ Using 960w quality:', quality960w.url);
                    return quality960w;
                }
            }
            
            // Look for blur_placeholder first (fastest loading for initial display)
            const blurPlaceholder = imageQualities.find(q => q.quality === 'blur_placeholder');
            if (blurPlaceholder && !skipBlur) {
                console.log('‚úÖ Found blur_placeholder quality (fastest):', blurPlaceholder.url);
                return blurPlaceholder;
            }
            
            // Look for 640w as fast loading choice with modern formats
            const quality640w = imageQualities.find(q => q.resolution === '640w');
            if (quality640w) {
                if (quality640w.formats) {
                    // Prefer HEIF, then WebP, then JPEG
                    const bestFormat = quality640w.formats.heif || quality640w.formats.webp || quality640w.formats.jpg;
                    if (bestFormat) {
                        console.log('‚úÖ Found 640w quality with modern format:', Object.keys(quality640w.formats).find(f => quality640w.formats[f] === bestFormat));
                        return { ...quality640w, url: bestFormat };
                    }
                }
                console.log('‚úÖ Found 640w quality (fast):', quality640w.url);
                return quality640w;
            }
            
            // Look for 960w as high quality choice with modern formats
            const quality960w = imageQualities.find(q => q.resolution === '960w');
            if (quality960w) {
                if (quality960w.formats) {
                    // Prefer HEIF, then WebP, then JPEG
                    const bestFormat = quality960w.formats.heif || quality960w.formats.webp || quality960w.formats.jpg;
                    if (bestFormat) {
                        console.log('‚úÖ Found 960w quality with modern format:', Object.keys(quality960w.formats).find(f => quality960w.formats[f] === bestFormat));
                        return { ...quality960w, url: bestFormat };
                    }
                }
                console.log('‚úÖ Found 960w quality (high):', quality960w.url);
                return quality960w;
            }
            
            // Look for 320w as last resort (but not blur_placeholder)
            const quality320w = imageQualities.find(q => q.resolution === '320w');
            if (quality320w) {
                if (quality320w.formats) {
                    const bestFormat = quality320w.formats.heif || quality320w.formats.webp || quality320w.formats.jpg;
                    if (bestFormat) {
                        console.log('‚úÖ Using 320w quality with modern format:', Object.keys(quality320w.formats).find(f => quality320w.formats[f] === bestFormat));
                        return { ...quality320w, url: bestFormat };
                    }
                }
                console.log('‚úÖ Using 320w quality (fallback):', quality320w.url);
                return quality320w;
            }
            
            // Last resort - use first available quality (but not 4K or blur)
            const non4kQuality = imageQualities.find(q => q.resolution !== '4K' && q.resolution !== '2160w' && q.resolution !== '1440w' && q.quality !== 'blur_placeholder');
            console.log('üîç Last resort quality search - found:', non4kQuality ? non4kQuality.resolution : 'NONE');
            if (non4kQuality) {
                console.log('‚ö†Ô∏è Using non-4K quality as fallback:', non4kQuality.resolution);
                return non4kQuality;
            }
            
            console.log('‚ö†Ô∏è Using first available quality as last resort:', imageQualities[0].quality);
            return imageQualities[0];
        }
        
        // Generate modern responsive picture element with social media speed optimization
        function generateResponsivePicture(imageQualities, alt = '', className = '') {
            if (!imageQualities || imageQualities.length === 0) {
                return `<img src="/public/images/placeholder-project.jpg" alt="${alt}" class="${className}" loading="lazy">`;
            }
            
            // Get blur placeholder for instant loading
            const blurPlaceholder = imageQualities.find(q => q.quality === 'blur_placeholder');
            
            // Get available qualities for srcset (exclude blur and 4K)
            const availableQualities = imageQualities.filter(q => 
                q.quality !== 'blur_placeholder' && 
                q.quality !== '4K' && 
                q.quality !== '2160w' &&
                q.quality !== '1440w' // Skip 1440w for faster loading
            ).sort((a, b) => parseInt(a.resolution) - parseInt(b.resolution));
            
            if (availableQualities.length === 0) {
                return `<img src="/public/images/placeholder-project.jpg" alt="${alt}" class="${className}" loading="lazy">`;
            }
            
            // Build srcset strings for each format (social media optimized widths)
            let heifSrcset = '';
            let webpSrcset = '';
            let jpgSrcset = '';
            let fallbackSrc = '';
            
            // Social media optimized widths: 320, 640, 960, 1280, 1920
            const socialWidths = [320, 640, 960, 1280, 1920];
            
            for (const quality of availableQualities) {
                const width = parseInt(quality.resolution);
                if (isNaN(width) || !socialWidths.includes(width)) continue;
                
                // Build srcsets for each format (prioritize HEIF over AVIF for better Safari support)
                if (quality.formats?.heif) {
                    heifSrcset += `${quality.formats.heif} ${width}w, `;
                }
                if (quality.formats?.webp) {
                    webpSrcset += `${quality.formats.webp} ${width}w, `;
                }
                if (quality.formats?.jpg) {
                    jpgSrcset += `${quality.formats.jpg} ${width}w, `;
                    if (!fallbackSrc) fallbackSrc = quality.formats.jpg;
                } else if (quality.url) {
                    jpgSrcset += `${quality.url} ${width}w, `;
                    if (!fallbackSrc) fallbackSrc = quality.url;
                }
            }
            
            // Remove trailing commas
            heifSrcset = heifSrcset.replace(/, $/, '');
            webpSrcset = webpSrcset.replace(/, $/, '');
            jpgSrcset = jpgSrcset.replace(/, $/, '');
            
            if (!fallbackSrc) {
                fallbackSrc = availableQualities[0].url || '/public/images/placeholder-project.jpg';
            }
            
            // Social media optimized sizes attribute
            const sizes = '(max-width: 600px) 100vw, (max-width: 1200px) 70vw, 1200px';
            
            // Build the blur-up container with picture element
            let html = `<div class="social-image-container" style="position: relative; background: #0b0b0b; overflow: hidden;">`;
            
            // Blur placeholder for instant paint (Facebook/Instagram style)
            if (blurPlaceholder) {
                html += `<img class="blur-placeholder" src="${blurPlaceholder.url}" aria-hidden="true" style="position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; filter: blur(20px); transform: scale(1.05); transition: opacity 0.35s ease;">`;
            }
            
            // Main picture element
            html += `<picture class="${className}">`;
            
            // HEIF source (best compression, good Safari support)
            if (heifSrcset) {
                html += `<source type="image/heif" srcset="${heifSrcset}" sizes="${sizes}">`;
            }
            
            // WebP source (widely supported, great compression)
            if (webpSrcset) {
                html += `<source type="image/webp" srcset="${webpSrcset}" sizes="${sizes}">`;
            }
            
            // JPEG fallback (universal support)
            html += `<img src="${fallbackSrc}" srcset="${jpgSrcset}" sizes="${sizes}" alt="${alt}" loading="lazy" decoding="async" style="position: relative; display: block; width: 100%;" onload="this.classList.add('is-loaded'); this.parentElement.previousElementSibling.style.opacity='0';">`;
            
            html += `</picture></div>`;
            
            return html;
        }
        
        // Change video quality in modal (manual user selection) - SIMPLE
        function changeVideoQuality(selector, mediaIndex) {
            const selectedQuality = selector.value;
            const video = document.getElementById(`main-video-${mediaIndex}`);
            
            // Find the current project and media items
            const project = projects.find(p => p.content && p.content.length > 0);
            if (!project) return;
            
            const currentMedia = project.content[mediaIndex];
            
            if (!currentMedia.videoQualities || !video) return;
            
            const qualityData = currentMedia.videoQualities.find(q => q.quality === selectedQuality);
            if (qualityData) {
                console.log(`üé¨ User manually selected ${selectedQuality} quality`);
                
                const currentTime = video.currentTime;
                const wasPlaying = !video.paused;
                
                // Simple source change - user expects this to cause a brief interruption
                video.src = qualityData.url;
                video.currentTime = currentTime;
                
                if (wasPlaying) {
                    video.play().catch(err => console.log('Could not auto-resume:', err));
                }
                
                // Update state
                const streamState = activeAdaptiveStreams.get(mediaIndex);
                if (streamState) {
                    const qualityIndex = streamState.availableQualities.findIndex(q => q.quality === selectedQuality);
                    if (qualityIndex !== -1) {
                        streamState.selectedQualityIndex = qualityIndex;
                    }
                }
                
                // Update UI
                updateQualityUI(mediaIndex, selectedQuality);
                
                console.log(`‚úÖ Manual quality change complete - now playing ${selectedQuality}`);
            }
        }
        
        // Progressive image loading - silently upgrade quality in background
    // üéØ PROCESSING INDICATORS - Facebook/Instagram style
    function showProcessingIndicators(uploadResults) {
        console.log('üéØ Showing processing indicators for', uploadResults.length, 'files');
        
        uploadResults.forEach((result, index) => {
            const mediaIndex = index;
            const processingOverlay = createProcessingOverlay(mediaIndex);
            
            // Add overlay to the media viewer
            const mediaViewer = document.getElementById('mediaViewer');
            if (mediaViewer) {
                mediaViewer.appendChild(processingOverlay);
            }
            
            // Start polling for processing completion
            pollProcessingStatus(result.fileId, mediaIndex);
        });
    }
    
    function createProcessingOverlay(mediaIndex) {
        const overlay = document.createElement('div');
        overlay.id = `processing-overlay-${mediaIndex}`;
        overlay.className = 'processing-overlay';
        overlay.innerHTML = `
            <div class="processing-content">
                <div class="processing-spinner">
                    <div class="spinner"></div>
                </div>
                <div class="processing-text">Processing...</div>
                <div class="processing-subtext">Generating multiple formats</div>
            </div>
        `;
        return overlay;
    }
    
    function pollProcessingStatus(fileId, mediaIndex) {
        console.log(`üîÑ Polling processing status for ${fileId}`);
        
        const pollInterval = setInterval(async () => {
            try {
                // Check if the media item has been fully processed
                const response = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/projects');
                const data = await response.json();
                
                if (data.success && data.projects) {
                    const project = data.projects.find(p => p.content && p.content.some(m => m.mediaId === fileId));
                    if (project) {
                        const mediaItem = project.content.find(m => m.mediaId === fileId);
                        if (mediaItem && mediaItem.imageQualities && mediaItem.imageQualities.length > 5) {
                            // Processing complete!
                            console.log(`‚úÖ Processing complete for ${fileId}`);
                            clearInterval(pollInterval);
                            showProcessingComplete(mediaIndex);
                        }
                    }
                }
            } catch (error) {
                console.error('Error polling processing status:', error);
            }
        }, 2000); // Poll every 2 seconds
        
        // Stop polling after 30 seconds
        setTimeout(() => {
            clearInterval(pollInterval);
            console.log(`‚è∞ Polling timeout for ${fileId}`);
        }, 30000);
    }
    
    function showProcessingComplete(mediaIndex) {
        const overlay = document.getElementById(`processing-overlay-${mediaIndex}`);
        if (overlay) {
            // Show success animation
            overlay.innerHTML = `
                <div class="processing-content success">
                    <div class="success-checkmark">
                        <div class="checkmark"></div>
                    </div>
                    <div class="processing-text">Ready!</div>
                    <div class="processing-subtext">All formats generated</div>
                </div>
            `;
            
            // Remove overlay after 1 second
            setTimeout(() => {
                overlay.style.opacity = '0';
                setTimeout(() => {
                    overlay.remove();
                }, 300);
            }, 1000);
        }
    }

    // üöÄ FACEBOOK-STYLE BLUR-UP PROGRESSIVE LOADING
    // This creates the instant-feel loading experience like Facebook/Instagram
    function startProgressiveImageLoading(mediaIndex) {
            // Find the current project and media items
            const project = projects.find(p => p.content && p.content.length > 0);
            if (!project) return;
            
            const currentMedia = project.content[mediaIndex];
            const currentImg = document.getElementById(`progressive-image-${mediaIndex}`);
            
            if (!currentImg || !currentMedia.imageQualities || currentMedia.imageQualities.length === 0) {
                console.log('‚ö†Ô∏è Cannot start progressive loading - missing image or qualities');
                return;
            }
            
            // Prevent infinite loop - check if already processing or completed
            if (currentImg.dataset.processing === 'true' || currentImg.dataset.completed === 'true') {
                console.log(`‚ö†Ô∏è Progressive loading already in progress or completed for media ${mediaIndex}`);
                return;
            }
            
            // Mark as processing to prevent multiple calls
            currentImg.dataset.processing = 'true';
            
            // Check current quality
            const currentQuality = currentImg.dataset.quality;
            console.log(`üìä Progressive loading for media ${mediaIndex} - Current: ${currentQuality}`);
            console.log(`üîç Available image qualities:`, currentMedia.imageQualities);
            
            // If already at high quality, we're done!
            if (currentQuality === '1920w' || currentQuality === '1280w') {
                console.log(`‚úÖ Already at high quality (${currentQuality}) - removing blur`);
                currentImg.style.filter = 'none';
                currentImg.style.transform = 'scale(1)';
                return;
            }
            
            // Find the BEST quality (highest resolution)
            const bestQuality = currentMedia.imageQualities.find(q => q.resolution === '1920w')
                           || currentMedia.imageQualities.find(q => q.resolution === '1280w')
                           || currentMedia.imageQualities.find(q => q.resolution === '960w')
                           || null;
            
            if (!bestQuality) {
                console.log('‚ö†Ô∏è No high quality version found');
                console.log('üîç Available qualities:', currentMedia.imageQualities.map(q => q.resolution));
                currentImg.style.filter = 'none';
                currentImg.style.transform = 'scale(1)';
                return;
            }
            
            console.log(`üì• Upgrading from ${currentQuality} to ${bestQuality.resolution}`);
            console.log(`üîç Best quality details:`, bestQuality);
            
            // Preload the high quality image in the background
            const highQualityImg = new Image();
            
            highQualityImg.onload = () => {
                console.log(`‚úÖ ${bestQuality.resolution} loaded! Applying Facebook-style transition...`);
                
                // Cache it
                cacheImage(bestQuality.url, highQualityImg);
                
                // FACEBOOK-STYLE SMOOTH TRANSITION
                // Step 1: Remove blur while keeping the low-quality image visible
                currentImg.style.transition = 'filter 0.3s ease-out, transform 0.3s ease-out';
                currentImg.style.filter = 'blur(0px)';
                currentImg.style.transform = 'scale(1)';
                
                // Step 2: Fade to high quality after blur is removed
                setTimeout(() => {
                    currentImg.style.transition = 'opacity 0.2s ease-in-out';
                    currentImg.style.opacity = '0.5';
                    
                    setTimeout(() => {
                        // Swap to high quality
                        currentImg.src = bestQuality.url;
                        currentImg.dataset.quality = bestQuality.resolution;
                        currentImg.style.opacity = '1';
                        currentImg.dataset.processing = 'false';
                        currentImg.dataset.completed = 'true';
                        
                        console.log(`üéâ Successfully upgraded to ${bestQuality.resolution} with smooth transition!`);
                    }, 100);
                }, 300);
            };
            
            highQualityImg.onerror = () => {
                console.log(`‚ùå Failed to load ${bestQuality.resolution}, keeping current quality`);
                // Just remove blur effect
                currentImg.style.filter = 'none';
                currentImg.style.transform = 'scale(1)';
                currentImg.dataset.processing = 'false';
                currentImg.dataset.completed = 'true';
            };
            
            // Start loading the high quality image
            highQualityImg.src = bestQuality.url;
        }

        // Aggressive preloading of nearby images
        function preloadNearbyImages(centerIndex) {
            // Find the current project and media items
            const project = projects.find(p => p.content && p.content.length > 0);
            if (!project || !project.content) {
                console.log('‚ö†Ô∏è No project or content found for preloading');
                return;
            }

            const mediaItems = project.content;
            if (!mediaItems || mediaItems.length === 0) {
                console.log('‚ö†Ô∏è No media items found for preloading');
                return;
            }

            const totalImages = mediaItems.length;
            console.log(`üöÄ Starting aggressive preloading around index ${centerIndex} (total: ${totalImages})`);

            // Calculate range to preload (5 images before and after)
            const startIndex = Math.max(0, centerIndex - preloadRadius);
            const endIndex = Math.min(totalImages - 1, centerIndex + preloadRadius);

            for (let i = startIndex; i <= endIndex; i++) {
                if (i === centerIndex) continue; // Skip current image (already loaded)
                
                const media = mediaItems[i];
                if (!media || media.type !== 'image') continue;

                const preloadKey = `${media.url}_preload`;
                if (preloadQueue.has(preloadKey)) continue; // Already preloading

                preloadQueue.add(preloadKey);
                preloadImage(media, i);
            }
        }

        // Preload a single image (using lower quality for faster preloading)
        function preloadImage(media, index) {
            if (!media.imageQualities || media.imageQualities.length === 0) {
                console.log(`‚ö†Ô∏è No image qualities available for preload: ${media.url}`);
                return;
            }

            // For preloading, use 720p or lower quality for faster loading
            const preloadQuality = selectPreloadQuality(media.imageQualities);
            if (!preloadQuality) {
                console.log(`‚ö†Ô∏è No suitable quality for preload: ${media.url}`);
                return;
            }

            // Check if already cached
            if (getCachedImage(preloadQuality.url)) {
                console.log(`‚úÖ Image already cached: ${preloadQuality.quality} (index ${index})`);
                return;
            }

            console.log(`üîÑ Preloading ${preloadQuality.quality} quality for index ${index}: ${preloadQuality.url}`);

            // Preload the image
            const img = new Image();
            img.onload = () => {
                console.log(`‚úÖ Preloaded ${preloadQuality.quality} quality for index ${index}`);
                cacheImage(preloadQuality.url, img);
                preloadQueue.delete(`${media.url}_preload`);
            };
            img.onerror = () => {
                console.log(`‚ùå Failed to preload index ${index}: ${preloadQuality.url}`);
                preloadQueue.delete(`${media.url}_preload`);
            };
            img.src = preloadQuality.url;
        }

        // Select quality for preloading (prioritizes 720p for speed)
        function selectPreloadQuality(imageQualities) {
            if (!imageQualities || imageQualities.length === 0) {
                return null;
            }
            
            // Look for 720p first (fast preloading)
            const quality720p = imageQualities.find(q => q.quality === '720p');
            if (quality720p) {
                return quality720p;
            }
            
            // Look for 1080p as fallback
            const quality1080p = imageQualities.find(q => q.quality === '1080p');
            if (quality1080p) {
                return quality1080p;
            }
            
            // Skip 4K and other high qualities for preloading
            const lowQuality = imageQualities.find(q => 
                q.quality !== '4K' && 
                q.quality !== '100' && 
                q.quality !== '1440p' &&
                q.quality !== 'blur_placeholder'
            );
            
            return lowQuality || imageQualities[0];
        }
        
        // changeImageQuality function removed - no longer needed since image quality selector is removed
        
        // Upload queue management
        let uploadQueues = {}; // { projectId: { queue: [], current: null, uploading: false } }
        let globalUploadStats = {
            totalFiles: 0,
            completedFiles: 0,
            currentFile: null,
            currentProgress: 0,
            totalSize: 0,
            completedSize: 0
        };
        
        // Initialize upload queue for a project
        function initializeUploadQueue(projectId) {
            if (!uploadQueues[projectId]) {
                uploadQueues[projectId] = {
                    queue: [],
                    current: null,
                    uploading: false
                };
            }
        }

        // Global upload progress management
        function updateGlobalUploadStats() {
            let totalFiles = 0;
            let completedFiles = 0;
            let currentFile = null;
            let totalSize = 0;
            let completedSize = 0;
            let totalQueue = 0;

            // Calculate totals across all projects
            Object.values(uploadQueues).forEach(queue => {
                totalFiles += queue.queue.length;
                completedFiles += queue.queue.filter(file => file.status === 'completed').length;
                totalQueue += queue.queue.filter(file => file.status === 'pending').length;
                
                // Find current uploading file
                if (queue.current && queue.current.status === 'uploading') {
                    currentFile = queue.current;
                    currentFile.progress = currentFile.progress || 0;
                    totalSize += currentFile.size || 0;
                    completedSize += (currentFile.size || 0) * (currentFile.progress / 100);
                }
                
                // Add completed files sizes
                queue.queue.forEach(file => {
                    if (file.status === 'completed') {
                        totalSize += file.size || 0;
                        completedSize += file.size || 0;
                    }
                });
            });

            globalUploadStats = {
                totalFiles,
                completedFiles,
                currentFile,
                totalSize,
                completedSize,
                totalQueue
            };

            updateUploadProgressUI();
        }

        function updateUploadProgressUI() {
            const overlay = document.getElementById('uploadProgressOverlay');
            const stats = document.getElementById('uploadProgressStats');
            const fill = document.getElementById('uploadProgressFill');
            const size = document.getElementById('uploadProgressSize');
            const queue = document.getElementById('uploadProgressQueue');

            if (globalUploadStats.totalFiles === 0) {
                overlay.classList.remove('visible');
                return;
            }

            overlay.classList.add('visible');

            // Update file count
            stats.textContent = `File ${globalUploadStats.completedFiles + (globalUploadStats.currentFile ? 1 : 0)} of ${globalUploadStats.totalFiles}`;

            // Update progress bar
            const progress = globalUploadStats.totalFiles > 0 ? 
                ((globalUploadStats.completedFiles + (globalUploadStats.currentFile ? globalUploadStats.currentFile.progress / 100 : 0)) / globalUploadStats.totalFiles) * 100 : 0;
            fill.style.width = `${Math.min(progress, 100)}%`;

            // Update size info
            const totalMB = (globalUploadStats.totalSize / (1024 * 1024)).toFixed(1);
            const completedMB = (globalUploadStats.completedSize / (1024 * 1024)).toFixed(1);
            size.textContent = `${completedMB} MB / ${totalMB} MB`;

            // Update queue info
            queue.textContent = `Queue: ${globalUploadStats.totalQueue}`;
        }

        function hideUploadProgress() {
            const overlay = document.getElementById('uploadProgressOverlay');
            overlay.classList.remove('visible');
        }
        
        // Show upload indicators for a project
        function showUploadIndicators(projectId) {
            // Global overlay handles this now
            updateGlobalUploadStats();
        }
        
        // Hide upload indicators for a project
        function hideUploadIndicators(projectId) {
            // Global overlay handles this now
            updateGlobalUploadStats();
        }
        
        // Update queue count display
        function updateQueueCount(projectId) {
            const queueCount = document.getElementById(`queue-count-${projectId}`);
            const queue = uploadQueues[projectId];
            if (queueCount && queue) {
                queueCount.textContent = queue.queue.length;
            }
        }
        
        // Update progress circle
        // updateProgressCircle function removed - using global overlay now
        
        // Drag and drop event handlers for project tiles
        function handleProjectDragOver(e, projectId) {
            e.preventDefault();
            e.stopPropagation();
        }
        
        function handleProjectDragEnter(e, projectId) {
            e.preventDefault();
            e.stopPropagation();
            e.target.closest('.project-card').classList.add('drag-over');
        }
        
        function handleProjectDragLeave(e, projectId) {
            e.preventDefault();
            e.stopPropagation();
            // Only remove drag-over if we're actually leaving the card, not just moving to a child element
            if (!e.target.closest('.project-card').contains(e.relatedTarget)) {
                e.target.closest('.project-card').classList.remove('drag-over');
            }
        }
        
        function handleProjectDrop(e, projectId) {
            e.preventDefault();
            e.stopPropagation();
            e.target.closest('.project-card').classList.remove('drag-over');
            
            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                console.log(`üìÅ Dropped ${files.length} files on project ${projectId}`);
                addFilesToUploadQueue(projectId, Array.from(files));
            }
        }
        
        // Add files to upload queue
        function addFilesToUploadQueue(projectId, files) {
            initializeUploadQueue(projectId);
            
            // Add files to queue with status and size info
            files.forEach(file => {
                file.status = 'pending';
                file.size = file.size || 0; // Ensure size is available
                uploadQueues[projectId].queue.push(file);
            });
            
            updateQueueCount(projectId);
            updateGlobalUploadStats(); // Update global stats
            
            // Start processing queue if not already uploading
            if (!uploadQueues[projectId].uploading) {
                processUploadQueue(projectId);
            }
            
            console.log(`üì§ Added ${files.length} files to queue for project ${projectId}. Queue length: ${uploadQueues[projectId].queue.length}`);
        }
        
        // üöÄ LAMBDA-POWERED PARALLEL UPLOAD PROCESSING
        async function processUploadQueue(projectId) {
            const queue = uploadQueues[projectId];
            if (!queue || queue.uploading || queue.queue.length === 0) {
                return;
            }
            
            queue.uploading = true;
            updateGlobalUploadStats(); // Show global overlay
            
            // Get all files from queue for parallel processing
            const files = [...queue.queue];
            queue.queue = []; // Clear the queue
            
            console.log(`üöÄ Starting LAMBDA-POWERED parallel upload for ${files.length} files to project ${projectId}`);
            
            try {
                // Step 1: Generate presigned URLs for direct S3 upload
                console.log('‚ö° Step 1: Generating presigned URLs...');
                const prepareResponse = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/lambda-upload/prepare', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        files: files.map(file => ({
                            name: file.name,
                            type: file.type,
                            size: file.size
                        })),
                        projectId: projectId
                    })
                });
                
                const prepareData = await prepareResponse.json();
                if (!prepareData.success) {
                    throw new Error(prepareData.error);
                }
                
                console.log(`‚úÖ Generated ${prepareData.uploads.length} presigned URLs`);
                
                // Step 2: Upload files directly to S3 in parallel
                console.log('‚ö° Step 2: Uploading directly to S3 in parallel...');
                const uploadPromises = prepareData.uploads.map(async (uploadInfo, index) => {
                    const file = files[index];
                    queue.current = file;
                    file.status = 'uploading';
                    file.progress = 0;
                    updateGlobalUploadStats();
                    
                    console.log(`üöÄ Uploading ${file.name} directly to S3...`);
                    
                    // Simulate progress for better UX
                    let progress = 0;
                    const progressInterval = setInterval(() => {
                        progress += Math.random() * 15;
                        if (progress > 90) progress = 90;
                        file.progress = progress;
                        updateGlobalUploadStats();
                    }, 150);
                    
                    const uploadResponse = await fetch(uploadInfo.presignedUrl, {
                        method: 'PUT',
                        body: file,
                        headers: {
                            'Content-Type': file.type
                        }
                    });
                    
                    clearInterval(progressInterval);
                    
                    if (uploadResponse.ok) {
                        file.progress = 100;
                        file.status = 'completed';
                        console.log(`‚úÖ ${file.name} uploaded to S3 successfully`);
                        return {
                            ...uploadInfo,
                            uploadSuccess: true
                        };
                    } else {
                        throw new Error(`Failed to upload ${file.name} to S3`);
                    }
                });
                
                const uploadResults = await Promise.all(uploadPromises);
                console.log(`‚úÖ All ${uploadResults.length} files uploaded to S3 in parallel!`);
                
                // Step 3: Trigger Lambda processing
                console.log('‚ö° Step 3: Triggering parallel processing...');
                const processResponse = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/lambda-upload/process', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        uploadedFiles: uploadResults,
                        projectId: projectId
                    })
                });
                
                const processData = await processResponse.json();
                if (processData.success) {
                    console.log(`üéâ LAMBDA PROCESSING COMPLETE! ${processData.results.length} files processed in parallel!`);
                }
                
                // Step 4: Refresh projects and show processing status
                console.log('üîÑ Refreshing projects after LAMBDA upload...');
                await loadProjects();
                console.log('‚úÖ Projects refreshed after LAMBDA upload');
                
                // Show processing indicators for newly uploaded files
                showProcessingIndicators(uploadResults);
                
            } catch (error) {
                console.error('‚ùå Lambda upload failed:', error);
                console.log('üîÑ Falling back to regular upload...');
                
                // Fallback: Process files one by one with regular upload
                for (const file of files) {
                    queue.current = file;
                    file.status = 'uploading';
                    file.progress = 0;
                    updateGlobalUploadStats();
                    
                    try {
                        await uploadFileToProject(projectId, file);
                        file.status = 'completed';
                        file.progress = 100;
                        console.log(`‚úÖ Successfully uploaded ${file.name} (fallback)`);
                    } catch (uploadError) {
                        console.error(`‚ùå Failed to upload ${file.name}:`, uploadError);
                        file.status = 'failed';
                        file.error = uploadError.message;
                    }
                    
                    updateGlobalUploadStats();
                }
                
                await loadProjects();
            }
            
            queue.current = null;
            queue.uploading = false;
            
            // Check if any uploads are still running globally
            const anyUploadsRunning = Object.values(uploadQueues).some(q => q.uploading);
            if (!anyUploadsRunning) {
                // All uploads complete, hide overlay after a delay
                setTimeout(() => {
                    hideUploadProgress();
                }, 2000);
            }
            
            // Refresh projects to show new media (with delay to ensure server has processed cover image)
            setTimeout(async () => {
                console.log('üîÑ Refreshing projects after media upload...');
                await loadProjects();
                console.log('‚úÖ Projects refreshed after media upload');
            }, 1000);
        }
        
        // Upload a single file to a project
        async function uploadFileToProject(projectId, file) {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('projectId', projectId);
            formData.append('fileName', file.name); // Add fileName that the server expects
            
            const response = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/upload', {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload failed: ${response.statusText} - ${errorText}`);
            }
            
            return await response.json();
        }
        
        // Load projects and grid layout when page loads
        loadProjects();
        loadGridLayout();
        
        // Global drag cleanup system
        function setupGlobalDragCleanup() {
            // Prevent stuck drag ghosts
            document.addEventListener('dragend', function(event) {
                // Clear any stuck drag images
                const dragImages = document.querySelectorAll('[style*="position: absolute"][style*="-1000px"]');
                dragImages.forEach(img => {
                    if (document.body.contains(img)) {
                        document.body.removeChild(img);
                    }
                });
                
                // Remove any drag-over classes
                document.querySelectorAll('.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });
                
                console.log('üßπ Global drag cleanup completed');
            });
            
            // Prevent text selection during drag operations
            document.addEventListener('dragstart', function(event) {
                document.body.style.userSelect = 'none';
                document.body.style.webkitUserSelect = 'none';
            });
            
            document.addEventListener('dragend', function(event) {
                document.body.style.userSelect = '';
                document.body.style.webkitUserSelect = '';
            });
            
        // Emergency cleanup on escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                emergencyDragCleanup();
            }
            // Force reset drag system with Ctrl+R
            if (event.ctrlKey && event.key === 'r') {
                event.preventDefault();
                forceResetDragSystem();
            }
        });
        }
        
        function emergencyDragCleanup() {
            console.log('üö® Emergency drag cleanup triggered');
            
            // Reset all drag states
            isDragging = false;
            isDraggingToTrash = false;
            
            // Remove event listeners
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
        // Clean up visual elements (no clone to remove anymore)
            
            if (dropPlaceholder) {
                dropPlaceholder.remove();
                dropPlaceholder = null;
            }
            
            // CRITICAL: Ensure ALL items are visible (not just the dragged one)
            document.querySelectorAll('.media-item.removed').forEach(el => {
                el.classList.remove('removed');
                el.style.opacity = '1';
            });
            
            if (draggedElement) {
                draggedElement.classList.remove('removed');
                draggedElement.style.opacity = '1';
                draggedElement = null;
            }
            
            // Remove dragging class from modal
            const modal = document.querySelector('.media-viewer-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
            
            // Restore text selection
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';
            document.body.style.mozUserSelect = '';
            document.body.style.msUserSelect = '';
            
            // Reset drag variables
            dragOffset = { x: 0, y: 0 };
            originalPosition = null;
            draggedIndex = null;
            currentProject = null;
            dragStartPosition = null;
        }
        
        // Add event listener for section title changes
        document.addEventListener('DOMContentLoaded', function() {
            setupGlobalDragCleanup();
            const sectionTitleInput = document.getElementById('sectionTitle');
            const saveTitleBtn = document.getElementById('saveTitleBtn');
            
            if (sectionTitleInput) {
                sectionTitleInput.addEventListener('input', function() {
                    // Update the gridLayout object immediately
                    gridLayout.sectionTitle = this.value;
                    // Update live preview immediately
                    renderLivePreview();
                });
                
                // Save to database when user stops typing (debounced)
                let saveTimeout;
                sectionTitleInput.addEventListener('input', function() {
                    clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => {
                        saveGridLayout();
                        console.log('üíæ Auto-saved section title:', gridLayout.sectionTitle);
                    }, 1000); // Save 1 second after user stops typing
                });
            }
            
            if (saveTitleBtn) {
                saveTitleBtn.addEventListener('click', function() {
                    // Update gridLayout and save immediately
                    const titleValue = document.getElementById('sectionTitle').value;
                    gridLayout.sectionTitle = titleValue;
                    saveGridLayout();
                    console.log('üíæ Manually saved section title:', titleValue);
                    
                    // Show brief feedback
                    this.textContent = '‚úì';
                    this.style.background = '#27ae60';
                    setTimeout(() => {
                        this.textContent = 'üíæ';
                        this.style.background = '#27ae60';
                    }, 1000);
                });
            }
        });
        
        async function loadProjects() {
            try {
                console.log('üîÑ Loading projects...');
                const response = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/projects');
                console.log('üì° Response status:', response.status);
                const data = await response.json();
                console.log('üìä Projects data:', data);
                
                // Filter out the grid_layout entry - it's not a real project
                projects = (data.projects || []).filter(project => project.id !== 'grid_layout');
                console.log('üìÅ Filtered projects array:', projects);
                
                // Debug: Log media counts and cover images for each project
                projects.forEach(project => {
                    console.log(`üìä Project "${project.title}" has ${project.content ? project.content.length : 0} media items:`, project.content);
                    console.log(`üñºÔ∏è Project "${project.title}" cover image:`, project.coverImage);
                    
                    // Fix: Filter out undefined/invalid media items
                    if (project.content && Array.isArray(project.content)) {
                        const validContent = project.content.filter(item => {
                            const isValid = item && 
                                item.type && 
                                (item.url || item.thumbnailUrl) && 
                                item.mediaId;
                            
                            if (!isValid) {
                                console.log(`üîç Invalid item details:`, {
                                    item: item,
                                    hasType: !!item?.type,
                                    hasUrl: !!(item?.url || item?.thumbnailUrl),
                                    hasMediaId: !!item?.mediaId,
                                    mediaIdValue: item?.mediaId
                                });
                            }
                            
                            return isValid;
                        });
                        
                        if (validContent.length !== project.content.length) {
                            console.log(`üîß Filtered out ${project.content.length - validContent.length} invalid items from "${project.title}"`);
                            project.content = validContent;
                        }
                    }
                });
                renderProjects();
                
                // Preload thumbnails for better performance
                preloadProjectThumbnails();
            } catch (error) {
                console.error('‚ùå Failed to load projects:', error);
            }
        }
        
        async function preloadProjectThumbnails() {
            const imageUrls = [];
            
            // Collect ALL thumbnail URLs from ALL projects (images AND videos)
            projects.forEach(project => {
                // Add project cover image to preloading
                if (project.coverImage) {
                    imageUrls.push(project.coverImage);
                }
                
                if (project.content && Array.isArray(project.content)) {
                    project.content.forEach(item => {
                        if (item.type === 'image') {
                            // For images, use thumbnail if available, otherwise original
                            imageUrls.push(item.thumbnailUrl || item.url);
                        } else if (item.type === 'video') {
                            // For videos, always use thumbnail
                            imageUrls.push(item.thumbnailUrl || item.url);
                        }
                    });
                }
            });
            
            console.log(`üñºÔ∏è Aggressively preloading ${imageUrls.length} media thumbnails across all projects...`);
            
            // Show preloading progress
            if (imageUrls.length > 0) {
                showPreloadProgress(imageUrls.length);
            }
            
            // Preload images in larger batches for faster loading
            const batchSize = 10; // Increased batch size for faster loading
            let loadedCount = 0;
            
            for (let i = 0; i < imageUrls.length; i += batchSize) {
                const batch = imageUrls.slice(i, i + batchSize);
                await Promise.all(batch.map(url => {
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.onload = () => {
                            // Cache the image immediately for instant access
                            cacheImage(url, img);
                            loadedCount++;
                            updatePreloadProgress(loadedCount, imageUrls.length);
                            resolve(url);
                        };
                        img.onerror = () => {
                            loadedCount++;
                            updatePreloadProgress(loadedCount, imageUrls.length);
                            resolve(url); // Still resolve even if image fails
                        };
                        img.src = url;
                    });
                }));
                
                // Small delay between batches to prevent overwhelming the browser
                if (i + batchSize < imageUrls.length) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            }
            
            hidePreloadProgress();
            console.log(`‚úÖ Aggressively preloaded and cached ${imageUrls.length} thumbnails for instant gallery loading`);
        }
        
        function showPreloadProgress(totalImages) {
            // Create or update preload progress indicator
            let progressDiv = document.getElementById('preload-progress');
            if (!progressDiv) {
                progressDiv = document.createElement('div');
                progressDiv.id = 'preload-progress';
                progressDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 15px 20px;
                    border-radius: 8px;
                    font-family: Arial, sans-serif;
                    font-size: 14px;
                    z-index: 10000;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                `;
                document.body.appendChild(progressDiv);
            }
            
            progressDiv.innerHTML = `
                <div style="margin-bottom: 8px;">üñºÔ∏è Preloading ${totalImages} thumbnails...</div>
                <div style="background: #333; height: 4px; border-radius: 2px; overflow: hidden;">
                    <div id="preload-progress-bar" style="background: #00ff88; height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                </div>
                <div id="preload-progress-text" style="margin-top: 8px; font-size: 12px; color: #ccc;">0%</div>
            `;
        }
        
        function updatePreloadProgress(loaded, total) {
            const progressBar = document.getElementById('preload-progress-bar');
            const progressText = document.getElementById('preload-progress-text');
            
            if (progressBar && progressText) {
                const percentage = Math.round((loaded / total) * 100);
                progressBar.style.width = `${percentage}%`;
                progressText.textContent = `${loaded}/${total} (${percentage}%)`;
            }
        }
        
        function hidePreloadProgress() {
            const progressDiv = document.getElementById('preload-progress');
            if (progressDiv) {
                setTimeout(() => {
                    progressDiv.remove();
                }, 1000); // Keep it visible for 1 second to show completion
            }
        }
        
        function renderLivePreview() {
            const livePreviewSection = document.getElementById('livePreview');
            if (!livePreviewSection) return;

            // Use EXACT same HTML structure as main page index.html
            livePreviewSection.innerHTML = `
                <section class="portfolio" style="padding-top: 0;">
                    <div class="container">
                        <h2 class="section-title">${gridLayout.sectionTitle || 'Our Work'}</h2>
                        <div class="portfolio-grid" id="livePreviewGrid" style="display: grid; grid-template-columns: repeat(${gridLayout.width}, 1fr); grid-template-rows: repeat(${gridLayout.height}, auto); gap: 20px; justify-content: center;">
                            ${generatePortfolioGridHTML()}
                        </div>
                    </div>
                </section>
            `;
        }

        function generatePortfolioGridHTML() {
            if (projects.length === 0) {
                return `
                    <div class="portfolio-item">
                        <div class="portfolio-cover">
                            <div class="portfolio-placeholder">
                                <div class="placeholder-icon">üé®</div>
                                <p>No projects yet</p>
                                <small>Add projects through admin panel</small>
                            </div>
                        </div>
                    </div>
                `;
            }

            // Use EXACT same logic as main page portfolio.js
            const totalPositions = gridLayout.width * gridLayout.height;
            const gridItems = [];

            // Fill ALL grid positions - create empty divs for spacing (exact same as main page)
            for (let i = 0; i < totalPositions; i++) {
                const projectId = gridLayout.positions[i];
                const project = projectId && projectId !== 'grid_layout' ? projects.find(p => p.id === projectId) : null;

                if (project) {
                    // Project exists at this position - make it draggable
                    gridItems.push(`
                        <div class="portfolio-item grid-project" data-project-id="${project.id}" data-position="${i}" draggable="true" style="grid-column: ${(i % gridLayout.width) + 1}; grid-row: ${Math.floor(i / gridLayout.width) + 1};">
                            <div class="portfolio-cover">
                                ${project.coverImage ? 
                                    `<img src="${project.coverImage}" alt="${project.title}" style="width: 100%; height: 100%; object-fit: cover;">` :
                                    `<div style="color: #888; text-align: center; display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%;">
                                        <div style="font-size: 2rem; margin-bottom: 10px;">üé®</div>
                                        <p>No Cover Image</p>
                                    </div>`
                                }
                            </div>
                            <h3>${project.title}</h3>
                            <p>${project.description || 'No description'}</p>
                            <div class="portfolio-stats">
                                ${project.content ? project.content.length : 0} media items
                            </div>
                        </div>
                    `);
                } else {
                    // Empty position - create invisible placeholder that takes up the same space as a project card (exact same as main page)
                    gridItems.push(`
                        <div class="portfolio-item portfolio-empty" style="grid-column: ${(i % gridLayout.width) + 1}; grid-row: ${Math.floor(i / gridLayout.width) + 1}; visibility: hidden; opacity: 0; pointer-events: none;">
                            <div class="portfolio-cover" style="min-height: 200px;">
                            </div>
                        </div>
                    `);
                }
            }

            return gridItems.join('');
        }
        
        function renderProjects() {
            console.log('üé® Rendering projects...', projects);
            
            // Render live preview
            renderLivePreview();
            
            // Render all projects list
            const projectsList = document.getElementById('projectsList');
            console.log('üìã Projects list element:', projectsList);
            if (!projectsList) {
                console.error('‚ùå Projects list element not found!');
                return;
            }
            
            if (projects.length === 0) {
                console.log('üì≠ No projects found, showing empty state');
                projectsList.innerHTML = '<p class="no-projects">No projects yet. Click "Add New Project" to get started!</p>';
                return;
            }
            
            console.log(`üìä Rendering ${projects.length} projects`);
            console.log('üîç isProjectReorderMode:', isProjectReorderMode);
            
            projectsList.innerHTML = projects.map((project, index) => `
                <div class="project-card" 
                     data-project-id="${project.id}" 
                     data-index="${index}" 
                     onclick="${isProjectReorderMode ? '' : `openMediaViewer('${project.id}')`}" 
                     ${isProjectReorderMode ? `onmousedown="handleProjectMouseDown(event, ${index})" style="cursor: move;"` : ''}
                     ondragover="handleProjectDragOver(event, '${project.id}')"
                     ondrop="handleProjectDrop(event, '${project.id}')"
                     ondragenter="handleProjectDragEnter(event, '${project.id}')"
                     ondragleave="handleProjectDragLeave(event, '${project.id}')">
                    
                    ${isProjectReorderMode ? `<div class="project-delete-btn" onclick="event.stopPropagation(); deleteProject('${project.id}')" title="Delete Project">√ó</div>` : ''}
                    
                    <!-- Upload indicators removed - using global overlay now -->
                    
                    <div class="project-cover">
                        ${project.coverImage || (project.content && project.content.length > 0 && project.content[0].url) ? 
                            `<img src="${project.coverImage || project.content[0].thumbnailUrl || project.content[0].url}" alt="${project.title}" loading="lazy">` :
                            '<div style="color: #888; text-align: center;">No Cover Image</div>'
                        }
                    </div>
                    <h3>${project.title}</h3>
                    <p>${project.description || 'No description'}</p>
                    <div class="project-stats">
                        ${project.content ? project.content.length : 0} media items
                    </div>
                    <div class="project-actions" onclick="event.stopPropagation()">
                        <button class="edit-btn" onclick="editProject('${project.id}')">Edit</button>
                        <button class="project-delete-btn" onclick="deleteProjectCompletely('${project.id}')">Delete</button>
                    </div>
                </div>
            `).join('');
            
            // Projects gallery is now always visible in the projects tab
        }
        
        
        function generateUniqueProjectId() {
            return 'proj_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }
        
        function addMedia(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (!project) return;
            
            // Create upload modal
            const uploadModal = document.createElement('div');
            uploadModal.className = 'upload-modal';
            uploadModal.innerHTML = `
                <div class="upload-modal-content">
                    <div class="upload-header">
                        <h3>Add Media to "${project.title}"</h3>
                        <button class="close-upload" onclick="this.closest('.upload-modal').remove()">&times;</button>
                    </div>
                    <div class="upload-area" id="uploadArea">
                        <div class="upload-placeholder">
                            <div class="upload-icon">üìÅ</div>
                            <p>Drag & drop files here</p>
                            <small>Images and videos supported</small>
                        </div>
                    </div>
                    <div class="upload-queue" id="uploadQueue" style="display: none;">
                        <h4>Uploading Files...</h4>
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                        <div class="queue-status">0 of 0 files</div>
                        <div class="queue-items"></div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(uploadModal);
            
            // Setup drag and drop
            const uploadArea = uploadModal.querySelector('#uploadArea');
            const uploadQueue = uploadModal.querySelector('#uploadQueue');
            const queueItems = uploadModal.querySelector('.queue-items');
            const progressFill = uploadModal.querySelector('.progress-fill');
            const queueStatus = uploadModal.querySelector('.queue-status');
            
            let uploadProgress = { total: 0, completed: 0, failed: 0 };
            
            // Drag and drop events
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
            });
            
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.add('drag-over');
                }, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, () => {
                    uploadArea.classList.remove('drag-over');
                }, false);
            });
            
            uploadArea.addEventListener('drop', async (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    await handleFileUploads(files, projectId, uploadQueue, queueItems, progressFill, queueStatus);
                }
            }, false);
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            async function handleFileUploads(files, projectId, uploadQueue, queueItems, progressFill, queueStatus) {
                uploadProgress = { total: files.length, completed: 0, failed: 0 };
                uploadQueue.style.display = 'block';
                
                // Show files in queue
                queueItems.innerHTML = '';
                Array.from(files).forEach((file, index) => {
                    const item = document.createElement('div');
                    item.className = 'queue-item';
                    item.innerHTML = `
                        <span class="file-name">${file.name}</span>
                        <span class="file-status">Pending...</span>
                    `;
                    queueItems.appendChild(item);
                });
                
                // Upload files one by one
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const queueItem = queueItems.children[i];
                    
                    try {
                        queueItem.querySelector('.file-status').textContent = 'Uploading...';
                        
                        const formData = new FormData();
                        formData.append('file', file);
                        formData.append('projectId', projectId);
                        formData.append('fileName', file.name);
                        
                        const response = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/upload', {
                            method: 'POST',
                            body: formData
                        });
                        
                        const result = await response.json();
                        
                        if (result.success) {
                            queueItem.querySelector('.file-status').textContent = 'Complete ‚úÖ';
                            uploadProgress.completed++;
                        } else {
                            throw new Error(result.error);
                        }
                    } catch (error) {
                        queueItem.querySelector('.file-status').textContent = 'Failed ‚ùå';
                        uploadProgress.failed++;
                    }
                    
                    // Update progress
                    const percentage = ((uploadProgress.completed + uploadProgress.failed) / uploadProgress.total) * 100;
                    progressFill.style.width = `${percentage}%`;
                    queueStatus.textContent = `${uploadProgress.completed + uploadProgress.failed} of ${uploadProgress.total} files (${uploadProgress.completed} successful, ${uploadProgress.failed} failed)`;
                }
                
                // Hide queue after 3 seconds
                setTimeout(() => {
                    uploadModal.remove();
                    loadProjects(); // Refresh project list
                }, 3000);
            }
        }
        
        function editProject(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (project) {
                // Set editing mode
                window.editingProjectId = projectId;
                
                // Pre-fill the form with existing project data
                document.getElementById('projectTitle').value = project.title;
                document.getElementById('projectDescription').value = project.description || '';
                
                // Update button text
                document.getElementById('saveBtn').textContent = 'Update Project';
                
                document.getElementById('projectForm').classList.add('show');
            }
        }
        
        
        document.getElementById('addProjectBtn').addEventListener('click', () => {
            if (isCreatingProject) {
                console.log('‚è≥ Project creation in progress, ignoring click');
                return;
            }
            document.getElementById('projectForm').classList.add('show');
        });
        
        document.getElementById('cancelBtn').addEventListener('click', () => {
            document.getElementById('projectForm').classList.remove('show');
            resetForm();
        });
        
        // Upload functionality will be added later for individual projects
        
        async function saveProject() {
            const title = document.getElementById('projectTitle').value.trim();
            const description = document.getElementById('projectDescription').value.trim();
            
            if (!title) {
                alert('Please enter a project title');
                return;
            }
            
            // Check if we're editing or creating
            const isEditing = window.editingProjectId;
            const projectId = isEditing ? window.editingProjectId : generateUniqueProjectId();
            
            // For new projects, use immediate creation with loading overlay
            if (!isEditing) {
                await createProjectImmediately(title, description, projectId);
                return;
            }
            
            // For editing, use the original flow
            await updateProject(projectId, title, description);
        }
        
        async function createProjectImmediately(title, description, projectId) {
            if (isCreatingProject) {
                console.log('‚è≥ Project creation already in progress, ignoring duplicate request');
                return;
            }
            
            isCreatingProject = true;
            
            // Show loading overlay immediately
            showProjectCreationOverlay();
            
            try {
                // Create project data
                const projectData = {
                    id: projectId,
                    title: title,
                    description: description,
                    coverImage: '',
                    content: [],
                    createdAt: new Date().toISOString(),
                    date: new Date().toISOString()
                };
                
                // Add to local projects array immediately for instant UI feedback
                projects.push(projectData);
                console.log('‚úÖ Added project to local array immediately:', projectData.title);
                
                // Update UI immediately
                renderProjects();
                document.getElementById('projectForm').classList.remove('show');
                resetForm();
                
                // Sync with backend silently in the background
                console.log('üîÑ Syncing project with backend silently...');
                const response = await fetch('/api/projects', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(projectData)
                });
                
                if (response.ok) {
                    console.log('‚úÖ Project synced with backend successfully');
                } else {
                    console.error('‚ùå Failed to sync project with backend');
                    // Remove from local array if backend sync failed
                    const index = projects.findIndex(p => p.id === projectId);
                    if (index !== -1) {
                        projects.splice(index, 1);
                        renderProjects();
                        alert('‚ùå Failed to create project. Please try again.');
                    }
                }
            } catch (error) {
                console.error('‚ùå Error creating project:', error);
                // Remove from local array if there was an error
                const index = projects.findIndex(p => p.id === projectId);
                if (index !== -1) {
                    projects.splice(index, 1);
                    renderProjects();
                }
                alert('‚ùå Failed to create project: ' + error.message);
            } finally {
                // Hide loading overlay
                hideProjectCreationOverlay();
                isCreatingProject = false;
            }
        }
        
        async function updateProject(projectId, title, description) {
            try {
                const existingProject = projects.find(p => p.id === projectId);
                if (!existingProject) {
                    alert('Project not found');
                    return;
                }
                
                const projectData = {
                    id: projectId,
                    title: title,
                    description: description,
                    coverImage: existingProject.coverImage || '',
                    content: existingProject.content || [],
                    updatedAt: new Date().toISOString(),
                    createdAt: existingProject.createdAt,
                    date: existingProject.date
                };
                
                const response = await fetch(`/api/projects/${projectId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(projectData)
                });
                
                if (response.ok) {
                    alert('‚úÖ Project updated successfully!');
                    document.getElementById('projectForm').classList.remove('show');
                    resetForm();
                    await loadProjects();
                } else {
                    throw new Error('Failed to update project');
                }
            } catch (error) {
                console.error('Update error:', error);
                alert('‚ùå Failed to update project: ' + error.message);
            }
        }
        
        function resetForm() {
            document.getElementById('projectTitle').value = '';
            document.getElementById('projectDescription').value = '';
            window.editingProjectId = null; // Reset editing mode
            document.getElementById('saveBtn').textContent = 'Create Project'; // Reset button text
        }
        
        function showProjectCreationOverlay() {
            // Add creating class to body to disable interactions
            document.body.classList.add('creating-project');
            
            // Create and show loading overlay
            const overlay = document.createElement('div');
            overlay.className = 'project-loading-overlay';
            overlay.innerHTML = `
                <div class="spinner"></div>
                <div class="message">Creating Project...</div>
                <div class="sub-message">Please wait while we set up your new project</div>
            `;
            overlay.id = 'projectCreationOverlay';
            
            document.body.appendChild(overlay);
            console.log('üì± Showing project creation overlay');
        }
        
        function hideProjectCreationOverlay() {
            // Remove creating class from body
            document.body.classList.remove('creating-project');
            
            // Remove loading overlay
            const overlay = document.getElementById('projectCreationOverlay');
            if (overlay) {
                overlay.remove();
                console.log('üì± Hiding project creation overlay');
            }
        }
        
        function openMediaViewer(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (!project) return;
            
            // Initialize local state for this project
            initializeLocalProjectState(project);
            
            // Create media viewer modal
            const viewerModal = document.createElement('div');
            viewerModal.className = 'media-viewer-modal';
            viewerModal.innerHTML = `
                <div class="media-viewer-content">
                    <div class="media-viewer-header">
                        <h3>${project.title}</h3>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            ${isReorderMode ? `
                                <div class="delete-drop-zone" id="deleteDropZone" 
                                     ondragover="handleDeleteDragOver(event)" 
                                     ondragenter="handleDeleteDragEnter(event)" 
                                     ondragleave="handleDeleteDragLeave(event)" 
                                     ondrop="handleDeleteDrop(event)">
                                    <div class="delete-icon">üóëÔ∏è</div>
                                    <div class="delete-text">Drop to Delete</div>
                                </div>
                            ` : ''}
                            <button class="reorder-toggle" id="reorderToggle" onclick="toggleMediaReorderMode()">Reorder Mode</button>
                            <button class="close-viewer" onclick="closeMediaViewer()">&times;</button>
                        </div>
                    </div>
                    <div class="media-viewer-body" id="mediaViewerBody">
                        ${project.content && project.content.length > 0 ? 
                            project.content
                                .filter(item => item && item.type && (item.url || item.thumbnailUrl) && item.mediaId)
                                .map((item, index) => {
                                const imageUrl = item.thumbnailUrl || item.url;
                                // For click handler, prioritize HLS URL for videos, otherwise use actual media URL
                                const clickUrl = item.type === 'video' ? (item.urls?.hls || item.url) : imageUrl;
                                console.log(`üñºÔ∏è Gallery thumbnail ${index}: ${item.type} - Using URL: ${imageUrl} (thumbnailUrl: ${item.thumbnailUrl})`);
                                console.log(`üîç Item URLs available:`, item.urls);
                                console.log(`üîç HLS URL:`, item.urls?.hls);
                                
                                // Check if this image is already cached
                                if (imageCache.has(imageUrl)) {
                                    console.log(`‚úÖ Thumbnail ${index} already cached`);
                                } else {
                                    console.log(`‚ö†Ô∏è Thumbnail ${index} not cached yet`);
                                }
                                
                                return `
                                <div class="media-item ${isReorderMode ? 'reorder-mode' : ''}" 
                                     data-index="${index}" 
                                     data-media-id="${item.mediaId || ''}"
                                     draggable="${isReorderMode ? 'true' : 'false'}"
                                     ondragstart="${isReorderMode ? `handleMediaDragStart(event, ${index})` : ''}"
                                     onmousedown="handleMouseDown(event, ${index})"
                                     onclick="handleMediaClick(event, '${clickUrl}', '${item.type}', ${index}, '${project.id}')">
                                    ${item.type === 'video' ? 
                                        `<img src="${imageUrl}" alt="${item.alt || 'Video'}" style="width: 100%; height: 100%; object-fit: contain; background: #1a1a1a;" data-video="true">` :
                                        `<img src="${imageUrl}" alt="${item.alt || 'Media'}" style="width: 100%; height: 100%; object-fit: contain; background: #1a1a1a;">`
                                    }
                                    ${item.type === 'video' ? '<div class="play-icon">‚ñ∂</div>' : ''}
                                </div>
                            `;
                            }).join('') :
                            '<div class="no-media">No media files yet. Click "Add Media" to upload content.</div>'
                        }
                    </div>
                </div>
            `;
            
            document.body.appendChild(viewerModal);
        }
        
        function closeMediaViewer() {
            // Reset reorder mode to false
            isReorderMode = false;
            console.log('üîÑ Reset reorder mode to false when closing modal');
            
            // Remove the modal
            const modal = document.querySelector('.media-viewer-modal');
            if (modal) {
                modal.remove();
            }
        }
        
        function updateProjectCardCount(projectId, newCount) {
            // Find the project card in the DOM and update the media count
            const projectCard = document.querySelector(`[data-project-id="${projectId}"]`);
            if (projectCard) {
                const statsElement = projectCard.querySelector('.project-stats');
                if (statsElement) {
                    statsElement.textContent = `${newCount} media items`;
                    console.log(`üîÑ Updated project card count to ${newCount} media items`);
                }
            }
            
            // Also update the live preview if it exists
            updateLivePreviewProjectCount(projectId, newCount);
        }
        
        function updateLivePreviewProjectCount(projectId, newCount) {
            // Find the project in the live preview grid and update its count
            const livePreviewGrid = document.getElementById('livePreview');
            if (livePreviewGrid) {
                const previewProject = livePreviewGrid.querySelector(`[data-project-id="${projectId}"]`);
                if (previewProject) {
                    const statsElement = previewProject.querySelector('.portfolio-stats');
                    if (statsElement) {
                        statsElement.textContent = `${newCount} media items`;
                        console.log(`üîÑ Updated live preview project count to ${newCount} media items`);
                    }
                }
            }
        }
        
        async function deleteProjectCompletely(projectId) {
            const project = projects.find(p => p.id === projectId);
            if (!project) {
                alert('Project not found');
                return;
            }
            
            const mediaCount = project.content ? project.content.length : 0;
            const confirmMessage = `Are you sure you want to COMPLETELY DELETE the project "${project.title}"?\n\nThis will permanently delete:\n‚Ä¢ The project itself\n‚Ä¢ All ${mediaCount} media files from storage\n‚Ä¢ All media records from the database\n‚Ä¢ Remove it from the grid layout\n\nThis action cannot be undone!`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                console.log(`üóëÔ∏è Completely deleting project: ${project.title} (${projectId})`);
                
                // Step 1: Delete all media files from S3 and DynamoDB
                if (project.content && project.content.length > 0) {
                    console.log(`üóëÔ∏è Deleting ${project.content.length} media files...`);
                    
                    for (const mediaItem of project.content) {
                        if (mediaItem.url) {
                            try {
                                // Extract S3 key from URL
                                const url = new URL(mediaItem.url);
                                const s3Key = decodeURIComponent(url.pathname.substring(1));
                                
                                console.log(`üóëÔ∏è Deleting from S3:`, s3Key);
                                
                                // Delete from S3 (original and thumbnail)
                                await fetch(`/api/media/${encodeURIComponent(s3Key)}`, {
                                    method: 'DELETE'
                                });
                                
                                console.log(`‚úÖ Successfully deleted from S3:`, s3Key);
                                
                                // Delete the media record from DynamoDB
                                console.log(`üóëÔ∏è Deleting media record from DynamoDB for s3Key:`, s3Key);
                                await fetch(`/api/media-record/${encodeURIComponent(s3Key)}`, {
                                    method: 'DELETE'
                                });
                                console.log(`‚úÖ Successfully deleted media record from DynamoDB:`, s3Key);
                                
                            } catch (s3Error) {
                                console.warn(`‚ö†Ô∏è Failed to delete ${mediaItem.url}:`, s3Error);
                            }
                        }
                    }
                }
                
                // Step 2: Delete the project from DynamoDB
                console.log(`üóëÔ∏è Deleting project from DynamoDB: ${projectId}`);
                const projectResponse = await fetch(`/api/projects/${projectId}`, {
                    method: 'DELETE'
                });
                
                if (!projectResponse.ok) {
                    throw new Error(`Failed to delete project: ${projectResponse.status}`);
                }
                
                console.log(`‚úÖ Successfully deleted project from DynamoDB: ${projectId}`);
                
                // Step 3: Remove project from grid layout
                if (gridLayout && gridLayout.positions) {
                    console.log(`üóëÔ∏è Removing project from grid layout...`);
                    
                    // Find and remove the project from all positions
                    Object.keys(gridLayout.positions).forEach(position => {
                        if (gridLayout.positions[position] === projectId) {
                            delete gridLayout.positions[position];
                            console.log(`üóëÔ∏è Removed project from grid position: ${position}`);
                        }
                    });
                    
                    // Save updated grid layout
                    await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/grid-layout', {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(gridLayout)
                    });
                    
                    console.log(`‚úÖ Updated grid layout without deleted project`);
                }
                
                // Step 4: Refresh the UI
                console.log(`üîÑ Refreshing UI...`);
                await loadProjects();
                await loadGridLayout();
                renderLivePreview();
                
                alert(`‚úÖ Successfully deleted project "${project.title}" and all its media!`);
                
            } catch (error) {
                console.error('‚ùå Error deleting project completely:', error);
                alert('‚ùå An error occurred while deleting the project. Please try again.');
            }
        }
        
        async function deleteAllMedia() {
            // Get the current project from the modal title
            const modal = document.querySelector('.media-viewer-modal');
            if (!modal) {
                console.error('‚ùå No media viewer modal found');
                return;
            }
            
            const projectTitle = modal.querySelector('h3').textContent;
            const project = projects.find(p => p.title === projectTitle);
            
            if (!project || !project.content || project.content.length === 0) {
                alert('No media items to delete');
                return;
            }
            
            const mediaCount = project.content.length;
            const confirmMessage = `Are you sure you want to delete ALL ${mediaCount} media items from "${project.title}"?\n\nThis action cannot be undone.`;
            
            if (!confirm(confirmMessage)) {
                return;
            }
            
            try {
                console.log(`üóëÔ∏è Deleting all ${mediaCount} media items from project: ${project.title}`);
                
                // Delete all media items from S3 and DynamoDB
                for (let i = 0; i < project.content.length; i++) {
                    const mediaItem = project.content[i];
                    
                    if (mediaItem.url) {
                        try {
                            // Extract S3 key from URL
                            const url = new URL(mediaItem.url);
                            const s3Key = decodeURIComponent(url.pathname.substring(1));
                            
                            console.log(`üóëÔ∏è Deleting from S3:`, s3Key);
                            
                            // Delete from S3
                            await fetch(`/api/media/${encodeURIComponent(s3Key)}`, {
                                method: 'DELETE'
                            });
                            
                            console.log(`‚úÖ Successfully deleted from S3:`, s3Key);
                            
                            // Delete the media record from DynamoDB
                            console.log(`üóëÔ∏è Deleting media record from DynamoDB for s3Key:`, s3Key);
                            await fetch(`/api/media-record/${encodeURIComponent(s3Key)}`, {
                                method: 'DELETE'
                            });
                            console.log(`‚úÖ Successfully deleted media record from DynamoDB:`, s3Key);
                            
                        } catch (s3Error) {
                            console.warn(`‚ö†Ô∏è Failed to delete ${mediaItem.url} from S3 or DynamoDB:`, s3Error);
                        }
                    }
                }
                
                // Clear the project content
                project.content = [];
                
                // Update local state immediately
                if (localProjectState && localProjectState.id === project.id) {
                    localProjectState.content = [];
                    console.log('üîÑ Updated local state after deleting all media');
                }
                
                // Update the UI immediately
                updateMediaViewerContent(project);
                
                // Update project card count immediately
                updateProjectCardCount(project.id, 0);
                
                // Save the updated project to the server
                const response = await fetch(`/api/projects/${project.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: []
                    })
                });
                
                if (response.ok) {
                    console.log('‚úÖ All media items deleted successfully');
                    alert(`‚úÖ Successfully deleted all ${mediaCount} media items!`);
                } else {
                    console.error('‚ùå Failed to save project after deleting all media');
                    alert('‚ùå Failed to save changes. Please refresh the page.');
                }
                
            } catch (error) {
                console.error('‚ùå Error deleting all media items:', error);
                alert('‚ùå An error occurred while deleting media items. Please try again.');
            }
        }
        
        function showFullscreen(url, type, mediaIndex = 0, projectId = null) {
            // Find the project by ID if provided, otherwise fall back to URL matching
            let project;
            if (projectId) {
                project = projects.find(p => p.id === projectId);
            } else {
                // Fallback: Find the project and media items by matching any URL (original, thumbnail, or quality)
                project = projects.find(p => p.content && p.content.some(item => 
                    item.url === url || 
                    item.thumbnailUrl === url ||
                    (item.imageQualities && item.imageQualities.some(q => q.url === url)) ||
                    (item.videoQualities && item.videoQualities.some(q => q.url === url))
                ));
            }
            
            if (!project || !project.content) {
                console.error('‚ùå Project not found for ID:', projectId, 'or URL:', url);
                return;
            }
            
            const mediaItems = project.content;
            let currentIndex = mediaIndex;
            
            // Start aggressive preloading of nearby images
            preloadNearbyImages(currentIndex);
            
            const fullscreenModal = document.createElement('div');
            fullscreenModal.className = 'fullscreen-modal';
            
            function updateMedia() {
                const currentMedia = mediaItems[currentIndex];
                const prevDisabled = currentIndex === 0 ? 'disabled' : '';
                const nextDisabled = currentIndex === mediaItems.length - 1 ? 'disabled' : '';
                
                console.log(`üé¨ Loading media ${currentIndex}: ${currentMedia.type} - URL: ${currentMedia.thumbnailUrl || currentMedia.url}`);

                let mediaHtml = '';
                if (currentMedia.type === 'video') {
                    // Check if HLS is available for seamless adaptive streaming
                    const hlsUrl = currentMedia.urls?.hls;
                    const hasHLS = hlsUrl && typeof Hls !== 'undefined';
                    
                    if (hasHLS) {
                        console.log('üé¨ Using HLS adaptive streaming for seamless quality switching');
                        
                        // Generate quality selector HTML for HLS (filter out 4K options)
                        const availableQualities = currentMedia.videoQualities ? currentMedia.videoQualities.filter(q => {
                            const is4K = q.quality === '4K' || q.quality === '2160p' || q.resolution === '2160p' || q.resolution === '4K';
                            return !is4K;
                        }) : [];
                        
                        // Auto quality selection - no manual selector needed
                        let qualitySelectorHtml = '';
                        
                        // Generate download menu HTML
                        let downloadMenuHtml = '';
                        if (currentMedia.videoQualities?.downloadableVersions && currentMedia.videoQualities.downloadableVersions.length > 0) {
                            downloadMenuHtml = `
                                <div style="position: absolute; top: 10px; left: 10px; z-index: 1000;">
                                    <button onclick="toggleDownloadMenu(${currentIndex})" style="background: rgba(0,0,0,0.7); color: white; border: 1px solid #00d4aa; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                        üì• Download
                                    </button>
                                    <div id="download-menu-${currentIndex}" style="display: none; position: absolute; top: 40px; left: 0; background: rgba(0,0,0,0.9); border: 1px solid #00d4aa; border-radius: 4px; padding: 8px; min-width: 150px;">
                                        ${currentMedia.videoQualities.downloadableVersions.map(v => `
                                            <a href="${v.url}" download style="display: block; color: white; text-decoration: none; padding: 8px; border-radius: 4px; margin-bottom: 4px; transition: background 0.2s;" 
                                               onmouseover="this.style.background='rgba(0,212,170,0.2)'" 
                                               onmouseout="this.style.background='transparent'">
                                                ${v.quality === 'original' ? 'üé¨ Original' : `üìπ ${v.quality}`}
                                            </a>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }
                        
                        mediaHtml = `
                            <video id="main-video-${currentIndex}" controls autoplay preload="metadata" poster="${currentMedia.urls?.thumbnail || ''}" style="border: 2px solid blue !important;">
                                Your browser does not support the video tag.
                            </video>
                            ${downloadMenuHtml}
                            ${qualitySelectorHtml}
                        `;
                        console.log('üé¨ Created HLS video with fixed viewer box');
                        
                        // CSS handles sizing - no JS intervention needed
                        setTimeout(() => {
                            const video = document.getElementById(`main-video-${currentIndex}`);
                            if (video) {
                                console.log('üé¨ Video element ready - CSS controls sizing');
                            }
                        }, 100);
                    } else {
                        // Fallback to legacy video quality system
                        console.log('üé¨ Using legacy video quality system');
                        
                        let selectedVideoUrl = currentMedia.url; // Default to original
                        let selectedQualityName = 'original';

                        // Start with 480p for good balance of speed and visual quality
                        console.log('üé¨ Current media videoQualities:', currentMedia.videoQualities);
                        if (currentMedia.videoQualities && currentMedia.videoQualities.length > 0) {
                            const startQuality = selectVideoQuality(currentMedia.videoQualities, 'lowest');
                            if (startQuality) {
                                selectedVideoUrl = startQuality.url;
                                selectedQualityName = startQuality.quality;
                                console.log(`üé¨ Starting with ${selectedQualityName} quality (skipping 240p/360p) - will upgrade adaptively to 1080p max`);
                            }
                        } else {
                            console.log('‚ö†Ô∏è No videoQualities found, using original URL:', currentMedia.url);
                        }

                        // Generate quality selector HTML (filter out 4K options)
                        const availableQualities = currentMedia.videoQualities ? currentMedia.videoQualities.filter(q => {
                            const is4K = q.quality === '4K' || q.quality === '2160p' || q.resolution === '2160p' || q.resolution === '4K';
                            return !is4K;
                        }) : [];
                        
                        // Auto quality selection - no manual selector needed
                        let qualitySelectorHtml = '';
                        
                        // Generate download menu HTML
                        let downloadMenuHtml = '';
                        if (currentMedia.videoQualities?.downloadableVersions && currentMedia.videoQualities.downloadableVersions.length > 0) {
                            downloadMenuHtml = `
                                <div style="position: absolute; top: 10px; left: 10px; z-index: 1000;">
                                    <button onclick="toggleDownloadMenu(${currentIndex})" style="background: rgba(0,0,0,0.7); color: white; border: 1px solid #00d4aa; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 14px;">
                                        üì• Download
                                    </button>
                                    <div id="download-menu-${currentIndex}" style="display: none; position: absolute; top: 40px; left: 0; background: rgba(0,0,0,0.9); border: 1px solid #00d4aa; border-radius: 4px; padding: 8px; min-width: 150px;">
                                        ${currentMedia.videoQualities.downloadableVersions.map(v => `
                                            <a href="${v.url}" download style="display: block; color: white; text-decoration: none; padding: 8px; border-radius: 4px; margin-bottom: 4px; transition: background 0.2s;" 
                                               onmouseover="this.style.background='rgba(0,212,170,0.2)'" 
                                               onmouseout="this.style.background='transparent'">
                                                ${v.quality === 'original' ? 'üé¨ Original' : `üìπ ${v.quality}`}
                                            </a>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }
                        
                        mediaHtml = `
                            <video id="main-video-${currentIndex}" controls autoplay preload="metadata" poster="${currentMedia.urls?.thumbnail || ''}" src="${selectedVideoUrl}" style="border: 2px solid blue !important;">
                                Your browser does not support the video tag.
                            </video>
                            ${downloadMenuHtml}
                            ${qualitySelectorHtml}
                        `;
                        console.log('üé¨ Created legacy video with fixed viewer box');
                        
                        // CSS handles sizing - no JS intervention needed
                        setTimeout(() => {
                            const video = document.getElementById(`main-video-${currentIndex}`);
                            if (video) {
                                console.log('üé¨ Video element ready - CSS controls sizing');
                            }
                        }, 100);
                    }
                } else if (currentMedia.type === 'image') {
                    // Check cache for highest available quality first with modern format support
                    let initialImageUrl;
                    let selectedQualityName = '720w'; // Default to 720w
                    let highestCachedQuality = null;
                    let skipBlurForCached = false;
                    
                    if (currentMedia.imageQualities && currentMedia.imageQualities.length > 0) {
                        // Check cache for highest quality with modern formats (start from highest and work down)
                        for (let i = currentMedia.imageQualities.length - 1; i >= 0; i--) {
                            const quality = currentMedia.imageQualities[i];
                            
                            // Skip blur_placeholder from cache check
                            if (quality.quality === 'blur_placeholder') continue;
                            
                            // Check main URL and all format URLs
                            const urlsToCheck = [quality.url];
                            if (quality.formats) {
                                urlsToCheck.push(...Object.values(quality.formats).filter(url => url));
                            }
                            
                            for (const url of urlsToCheck) {
                                if (getCachedImage(url)) {
                                    highestCachedQuality = quality;
                                    skipBlurForCached = true;
                                    break;
                                }
                            }
                            if (highestCachedQuality) break;
                        }
                        
                        // Always start with high quality for fullscreen (no blur)
                        const initialQuality = selectImageQuality(currentMedia.imageQualities, true); // skipBlur = true
                        if (initialQuality) {
                            initialImageUrl = initialQuality.url;
                            selectedQualityName = initialQuality.quality;
                            skipBlurForCached = true; // Force no blur for high quality
                            console.log(`üñºÔ∏è Starting with high quality (no blur): ${initialQuality.quality} (${initialImageUrl})`);
                        } else {
                            // Fallback to thumbnail if available (fastest possible)
                            if (currentMedia.thumbnailUrl) {
                                initialImageUrl = currentMedia.thumbnailUrl;
                                selectedQualityName = 'thumbnail';
                                console.log('üñºÔ∏è Using thumbnail for fastest loading:', initialImageUrl);
                            } else {
                                // Last resort - original
                                initialImageUrl = currentMedia.url;
                                selectedQualityName = 'original';
                                console.log('üñºÔ∏è No fast options, using original image:', initialImageUrl);
                            }
                        }
                    } else {
                        // Fallback to original if no qualities available
                        initialImageUrl = currentMedia.url;
                        selectedQualityName = 'original';
                    }

                    const qualitySelectorHtml = ''; // Removed image quality selector as per user request

                    mediaHtml = `
                        <div class="media-container" style="position: relative; display: flex; align-items: center; justify-content: center; width: 100vw; height: 100vh;">
                            <img id="progressive-image-${currentIndex}" 
                                 src="${initialImageUrl}" 
                                 data-quality="${selectedQualityName}"
                                 class="media-slide"
                                 style="max-width: 90vw; max-height: 90vh; 
                                        object-fit: contain; 
                                        ${skipBlurForCached ? 'filter: none; transform: scale(1);' : 'filter: blur(20px); transform: scale(1.1);'} 
                                        opacity: 1; 
                                        will-change: transform, filter, opacity;
                                        transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.3s ease;" 
                                 onload="console.log('üöÄ Image loaded - starting Facebook-style blur-up'); if (typeof startProgressiveImageLoading === 'function') { startProgressiveImageLoading(${currentIndex}); }">
                        </div>
                    `;
                }
                
                fullscreenModal.innerHTML = `
                    <div class="fullscreen-content">
                        <button class="close-fullscreen" onclick="this.closest('.fullscreen-modal').remove()">&times;</button>
                        <div class="media-counter">${currentIndex + 1} of ${mediaItems.length}</div>
                        <button class="nav-arrow prev" ${prevDisabled} onclick="navigateMedia(-1)">
                            &#8249;
                        </button>
                        <button class="nav-arrow next" ${nextDisabled} onclick="navigateMedia(1)">
                            &#8250;
                        </button>
                        ${mediaHtml}
                    </div>
                `;
                
                        // Initialize video player after DOM update
                if (currentMedia.type === 'video') {
                    // Use setTimeout to ensure video element is in DOM
                    setTimeout(() => {
                        const videoElement = document.getElementById(`main-video-${currentIndex}`);
                        if (videoElement) {
                            // Check if HLS is available
                            const hlsUrl = currentMedia.urls?.hls;
                            if (hlsUrl && typeof Hls !== 'undefined') {
                                console.log('üé¨ Initializing HLS player for video', currentIndex);
                                const hlsInitialized = initializeHLSPlayer(videoElement, hlsUrl, currentIndex);
                                if (!hlsInitialized) {
                                    console.log('üé¨ HLS failed, falling back to legacy adaptive streaming');
                                    if (currentMedia.videoQualities && currentMedia.videoQualities.length > 1) {
                                        startAdaptiveVideoStreaming(videoElement, currentIndex, currentMedia.videoQualities);
                                    }
                                }
                            } else {
                                console.log('üé¨ Initializing legacy adaptive streaming for video', currentIndex);
                                if (currentMedia.videoQualities && currentMedia.videoQualities.length > 1) {
                                    startAdaptiveVideoStreaming(videoElement, currentIndex, currentMedia.videoQualities);
                                }
                            }
                        }
                    }, 100);
                }
                
                // CRITICAL: Prevent videos from triggering progressive image loading
                // Videos should NOT call startProgressiveImageLoading as it causes DOM glitches
            }
            
            // Add the modal to the document
            document.body.appendChild(fullscreenModal);
            
            // Add navigation function to global scope
            window.navigateMedia = (direction) => {
                const newIndex = currentIndex + direction;
                if (newIndex >= 0 && newIndex < mediaItems.length) {
                    currentIndex = newIndex;
                    // Trigger preloading for the new position
                    preloadNearbyImages(currentIndex);
                    updateMedia();
                }
            };
            
            // Handle keyboard navigation
            function handleKeyPress(e) {
                if (e.key === 'ArrowLeft') {
                    window.navigateMedia(-1);
                } else if (e.key === 'ArrowRight') {
                    window.navigateMedia(1);
                } else if (e.key === 'Escape') {
                    fullscreenModal.remove();
                }
            }
            
            document.addEventListener('keydown', handleKeyPress);
            
            updateMedia();
            document.body.appendChild(fullscreenModal);
            
            // Clean up event listener when modal is closed
            const originalRemove = fullscreenModal.remove;
            fullscreenModal.remove = function() {
                document.removeEventListener('keydown', handleKeyPress);
                delete window.navigateMedia;
                originalRemove.call(this);
            };
            
            // Close on outside click
            fullscreenModal.addEventListener('click', (e) => {
                if (e.target === fullscreenModal) {
                    fullscreenModal.remove();
                }
            });
        }
        
        // Drag and Drop Functions for Media Reordering
        let draggedIndex = null;
        let currentProject = null;
        let draggedElement = null;
        let draggedClone = null;
        let dropPlaceholder = null;
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let originalPosition = null;
        let isDraggingToTrash = false;
        let dragStartPosition = null;
        let dragTimeout = null;
        
        function handleMouseDown(event, index) {
            if (!isReorderMode) return;
            
            // Prevent all default behaviors immediately
            event.preventDefault();
            event.stopPropagation();
            event.stopImmediatePropagation();
            
            // Reset any existing drag state
            isDragging = false;
            isDraggingToTrash = false;
            
            draggedIndex = index;
            draggedElement = event.target.closest('.media-item');
            
            // Find the current project
            const projectCard = event.target.closest('.media-viewer-modal');
            const projectTitle = projectCard.querySelector('h3').textContent;
            currentProject = projects.find(p => p.title === projectTitle);
            
            // Calculate offset from mouse to element
            const rect = draggedElement.getBoundingClientRect();
            dragOffset.x = event.clientX - rect.left;
            dragOffset.y = event.clientY - rect.top;
            
            // Store original position for snap-back
            originalPosition = {
                element: draggedElement,
                parent: draggedElement.parentNode,
                nextSibling: draggedElement.nextSibling
            };
            
            // Store initial mouse position for threshold calculation
            dragStartPosition = {
                x: event.clientX,
                y: event.clientY
            };
            
            draggedClone = null;
            
            // Add event listeners with passive: false to ensure we can preventDefault
            document.addEventListener('mousemove', handleMouseMove, { passive: false });
            document.addEventListener('mouseup', handleMouseUp, { passive: false });
            
            // Set a safety timeout to prevent stuck drag state
            dragTimeout = setTimeout(() => {
                console.log('‚ö†Ô∏è Drag timeout - forcing cleanup');
                resetDragState();
            }, 10000); // 10 second timeout
            
            // Prevent text selection and other interactions globally
            document.body.style.userSelect = 'none';
            document.body.style.webkitUserSelect = 'none';
            document.body.style.mozUserSelect = 'none';
            document.body.style.msUserSelect = 'none';
        }
        
        function handleMouseMove(event) {
            // Always prevent default to stop text selection and other behaviors
            event.preventDefault();
            event.stopPropagation();
            
            // Check if we should start dragging (threshold-based)
            if (!isDragging && draggedElement && !draggedClone && dragStartPosition) {
                const mouseX = event.clientX;
                const mouseY = event.clientY;
                
                // Calculate distance moved from start position
                const distance = Math.sqrt(
                    Math.pow(mouseX - dragStartPosition.x, 2) + 
                    Math.pow(mouseY - dragStartPosition.y, 2)
                );
                
                // Only start dragging if moved more than 10 pixels (increased threshold)
                if (distance > 10) {
                    isDragging = true;
                    
                    // Add dragging class to modal to prevent hover effects
                    const modal = document.querySelector('.media-viewer-modal');
                    if (modal) {
                        modal.classList.add('dragging');
                    }
                    
                    // DON'T create a floating clone - just hide the original element
                    // The anchored drop indicators will show where to drop
                    draggedElement.classList.add('removed');
                    
                    console.log('üéØ Drag started - threshold exceeded');
                } else {
                    return; // Don't process further until threshold is met
                }
            }
            
            if (!isDragging) return;
            
            const mouseX = event.clientX;
            const mouseY = event.clientY;
            
            // Check if dragging toward delete zone in header
            const deleteZone = document.getElementById('deleteDropZone');
            if (deleteZone) {
                const deleteRect = deleteZone.getBoundingClientRect();
                const distanceToDelete = Math.sqrt(
                    Math.pow(mouseX - (deleteRect.left + deleteRect.width/2), 2) + 
                    Math.pow(mouseY - (deleteRect.top + deleteRect.height/2), 2)
                );
                
                if (distanceToDelete < 80) { // pixels
                    // Switch to HTML5 drag mode for delete
                    isDraggingToTrash = true;
                    removeDropPlaceholder();
                    console.log('üéØ Near delete zone - switching to HTML5 drag');
                    return;
                } else {
                    // Reset to reorder mode if moved away from delete zone
                    isDraggingToTrash = false;
                    console.log('üéØ Moved away from delete zone - switching back to reorder mode');
                }
            }
            
            
            // Find the closest drop position
            const dropPosition = findClosestDropPosition(event.clientX, event.clientY);
            if (dropPosition) {
                createDropPlaceholder(dropPosition);
            } else {
                // Remove placeholder if outside valid drop zones
                removeDropPlaceholder();
            }
        }
        
        function findClosestDropPosition(mouseX, mouseY) {
            const mediaItems = document.querySelectorAll('.media-item:not(.removed)');
            let closestPosition = null;
            let closestDistance = Infinity;
            
            console.log('üîç Finding drop position for:', mouseX, mouseY);
            console.log('üì¶ Media items found:', mediaItems.length);
            
            // Check if mouse is within the browser window bounds
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const isWithinWindow = mouseX >= 0 && mouseX <= windowWidth && mouseY >= 0 && mouseY <= windowHeight;
            
            if (!isWithinWindow) {
                console.log('‚ùå Outside browser window');
                return null; // Outside browser window - no drop position
            }
            
            // Get the media viewer bounds (including header)
            const viewerModal = document.querySelector('.media-viewer-modal');
            if (!viewerModal) {
                console.log('‚ùå No media viewer modal found');
                return null;
            }
            
            const viewerRect = viewerModal.getBoundingClientRect();
            console.log('üì∫ Viewer bounds (including header):', viewerRect);
            
            // Check if mouse is in the media viewer area (including header)
            const isInViewer = mouseY >= viewerRect.top && mouseY <= viewerRect.bottom && 
                             mouseX >= viewerRect.left && mouseX <= viewerRect.right;
            
            if (!isInViewer) {
                console.log('‚ùå Outside media viewer (including header)');
                return null; // Outside media viewer
            }
            
            console.log('‚úÖ Mouse is in viewer area');
            
            // Create invisible drop zones for each gap between items
            for (let i = 0; i <= mediaItems.length; i++) {
                const dropZone = calculateDropZone(mediaItems, i);
                console.log(`üéØ Drop zone ${i}:`, dropZone);
                
                if (dropZone && isPointInDropZone(mouseX, mouseY, dropZone)) {
                    const distance = Math.min(
                        Math.abs(mouseX - dropZone.left),
                        Math.abs(mouseX - dropZone.right),
                        Math.abs(mouseY - dropZone.top),
                        Math.abs(mouseY - dropZone.bottom)
                    );
                    
                    console.log(`‚úÖ Point in drop zone ${i}, distance:`, distance);
                    
                    if (distance < closestDistance) {
                        closestDistance = distance;
                    
                    // Determine if this is the same position as the dragged item
                    let side = 'between';
                    if (draggedIndex !== null && i === draggedIndex) {
                        // Check if we're actually over the same tile or between tiles
                        // If we're at the same index, check if the mouse is over the actual tile
                        const draggedElement = document.querySelector(`[data-index="${draggedIndex}"]`);
                        if (draggedElement) {
                            const tileRect = draggedElement.getBoundingClientRect();
                            const isOverTile = mouseX >= tileRect.left && mouseX <= tileRect.right && 
                                             mouseY >= tileRect.top && mouseY <= tileRect.bottom;
                            
                            if (isOverTile) {
                                side = 'same'; // Actually over the same tile
                            } else {
                                side = 'between'; // Between tiles at same index
                            }
                        } else {
                            side = 'between'; // Default to between if we can't find the element
                        }
                    }
                    
                        closestPosition = {
                        index: i,
                        side: side,
                        dropZone: dropZone
                    };
                    console.log(`üéØ New closest position: index ${i}, side: ${side}`);
                }
                }
            }
            
            console.log('üéØ Final closest position:', closestPosition);
            return closestPosition;
        }
        
        function calculateDropZone(mediaItems, position) {
            const viewerBody = document.getElementById('mediaViewerBody');
            const viewerRect = viewerBody.getBoundingClientRect();
            
            console.log(`üîß Calculating drop zone ${position} for ${mediaItems.length} items`);
            
            // Calculate the drop zone for this position
            let leftEdge, rightEdge, topEdge, bottomEdge;
            
            if (position === 0) {
                // Before first item - use the ENTIRE EMPTY SPACE to the left
                if (mediaItems.length === 0) {
                    // No items - use full viewer width
                    leftEdge = viewerRect.left;
                    rightEdge = viewerRect.right;
                    console.log('üì¶ No items - using full viewer width');
                } else {
                const firstItem = mediaItems[0];
                const firstRect = firstItem.getBoundingClientRect();
                    // Use ALL the empty space from the viewer's left edge to the first item's left edge
                    leftEdge = viewerRect.left;
                    rightEdge = firstRect.left;
                    console.log('üì¶ Entire empty space before first item:', firstRect, '‚Üí zone:', leftEdge, 'to', rightEdge);
                }
            } else if (position === mediaItems.length) {
                // After last item - use the ENTIRE EMPTY SPACE to the right
                const lastItem = mediaItems[mediaItems.length - 1];
                const lastRect = lastItem.getBoundingClientRect();
                // Use ALL the empty space from the last item's right edge to the viewer's right edge
                leftEdge = lastRect.right;
                rightEdge = viewerRect.right;
                console.log('üì¶ Entire empty space after last item:', lastRect, '‚Üí zone:', leftEdge, 'to', rightEdge);
            } else {
                // Between two items - use the RIGHT HALF of left item + LEFT HALF of right item
                const leftItem = mediaItems[position - 1];
                const rightItem = mediaItems[position];
                const leftRect = leftItem.getBoundingClientRect();
                const rightRect = rightItem.getBoundingClientRect();
                
                // Combine the right half of the left item with the left half of the right item
                const leftItemWidth = leftRect.width;
                const rightItemWidth = rightRect.width;
                
                leftEdge = leftRect.left + (leftItemWidth / 2);
                rightEdge = rightRect.left + (rightItemWidth / 2);
                
                console.log(`üì¶ Between items ${position-1} and ${position}:`, leftRect, rightRect, '‚Üí combined halves zone:', leftEdge, 'to', rightEdge);
            }
            
            // Set vertical bounds to match viewer height
            topEdge = viewerRect.top;
            bottomEdge = viewerRect.bottom;
            
            // Ensure valid drop zone (left < right)
            if (leftEdge >= rightEdge) {
                console.warn(`‚ö†Ô∏è Invalid drop zone ${position}: left (${leftEdge}) >= right (${rightEdge}), adjusting...`);
                const center = (leftEdge + rightEdge) / 2;
                leftEdge = center - 25;
                rightEdge = center + 25;
            }
            
            const dropZone = {
                left: leftEdge,
                right: rightEdge,
                top: topEdge,
                bottom: bottomEdge
            };
            
            console.log(`üéØ Final drop zone ${position}:`, dropZone);
            return dropZone;
        }
        
        function isPointInDropZone(x, y, zone) {
            return x >= zone.left && x <= zone.right && y >= zone.top && y <= zone.bottom;
        }
        
        function createDropPlaceholder(position) {
            // Remove existing indicator
            removeDropPlaceholder();
            
            if (!position) return;
            
            const mediaItems = document.querySelectorAll('.media-item:not(.removed)');
            const viewerBody = document.getElementById('mediaViewerBody');
            const viewerRect = viewerBody.getBoundingClientRect();
            
            // Create a vertical line indicator at the drop position
            dropPlaceholder = document.createElement('div');
            dropPlaceholder.className = 'drop-indicator-line';
            dropPlaceholder.style.position = 'absolute';
            dropPlaceholder.style.zIndex = '1000';
            dropPlaceholder.style.pointerEvents = 'none';
            dropPlaceholder.style.backgroundColor = '#4CAF50';
            dropPlaceholder.style.width = '4px';
            dropPlaceholder.style.borderRadius = '2px';
            dropPlaceholder.style.boxShadow = '0 0 8px rgba(76, 175, 80, 0.6)';
            
        if (position.index === 0) {
            // Position before first item
            if (mediaItems.length === 0) {
                // No items - position at the left edge of viewer
                const relativeLeft = 10;
                const relativeTop = 10;
                dropPlaceholder.style.left = relativeLeft + 'px';
                dropPlaceholder.style.top = relativeTop + 'px';
                dropPlaceholder.style.height = '100px'; // Default height
            } else {
                const firstItem = mediaItems[0];
                const firstRect = firstItem.getBoundingClientRect();
                const relativeLeft = firstRect.left - viewerRect.left - 10;
                const relativeTop = firstRect.top - viewerRect.top;
                dropPlaceholder.style.left = relativeLeft + 'px';
                dropPlaceholder.style.top = relativeTop + 'px';
                dropPlaceholder.style.height = firstRect.height + 'px';
            }
        } else if (position.index >= mediaItems.length) {
            // Position after last item
            if (mediaItems.length === 0) {
                // No items - position at the right edge of viewer
                const relativeLeft = viewerRect.width - 20;
                const relativeTop = 10;
                dropPlaceholder.style.left = relativeLeft + 'px';
                dropPlaceholder.style.top = relativeTop + 'px';
                dropPlaceholder.style.height = '100px'; // Default height
            } else {
                const lastItem = mediaItems[mediaItems.length - 1];
                const lastRect = lastItem.getBoundingClientRect();
                // Position the indicator at the right edge of the last item
                const relativeLeft = lastRect.right - viewerRect.left + 5; // 5px to the right of the last item
                const relativeTop = lastRect.top - viewerRect.top;
                dropPlaceholder.style.left = relativeLeft + 'px';
                dropPlaceholder.style.top = relativeTop + 'px';
                dropPlaceholder.style.height = lastRect.height + 'px';
            }
        } else {
            // Position between items
            const leftItem = mediaItems[position.index - 1];
            const rightItem = mediaItems[position.index];
            const leftRect = leftItem.getBoundingClientRect();
            const rightRect = rightItem.getBoundingClientRect();
            const gapCenter = (leftRect.right + rightRect.left) / 2;
            const relativeLeft = gapCenter - viewerRect.left - 2; // Center the 4px line
            const relativeTop = leftRect.top - viewerRect.top;
            const height = Math.max(leftRect.height, rightRect.height);
            dropPlaceholder.style.left = relativeLeft + 'px';
            dropPlaceholder.style.top = relativeTop + 'px';
            dropPlaceholder.style.height = height + 'px';
        }
            
            viewerBody.appendChild(dropPlaceholder);
        }
        
        function removeDropPlaceholder() {
            if (dropPlaceholder) {
                dropPlaceholder.remove();
                dropPlaceholder = null;
            }
        }
        
        function cleanupDrag() {
            // Restore original element
            if (draggedElement) {
                draggedElement.classList.remove('removed');
            }
            
            // Remove dragging class from modal
            const modal = document.querySelector('.media-viewer-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
            
            // Reset drag state
            isDragging = false;
            draggedIndex = null;
            draggedElement = null;
            draggedClone = null;
            isDraggingToTrash = false;
            dropPlaceholder = null;
            originalPosition = null;
            dragStartPosition = null;
        }
        
        function handleMouseUp(event) {
            console.log('üñ±Ô∏è Mouse up event triggered');
            
            // Always prevent default and restore text selection
            event.preventDefault();
            event.stopPropagation();
            
            // Restore text selection globally
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';
            document.body.style.mozUserSelect = '';
            document.body.style.msUserSelect = '';
            
            // Remove event listeners first
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
            // Always clean up drag state
            const wasDragging = isDragging || isDraggingToTrash;
            console.log('üßπ Was dragging:', wasDragging, 'isDragging:', isDragging, 'isDraggingToTrash:', isDraggingToTrash);
            
            if (!wasDragging) {
                console.log('üßπ Mouse up - no drag state to clean, resetting variables');
                // Reset variables even if not dragging
                resetDragState();
                return;
            }
            
            console.log('üßπ Mouse up - cleaning drag state');
            
            // If dragging to trash, handle deletion
            if (isDraggingToTrash) {
                console.log('üóëÔ∏è Drag to trash detected - triggering deletion');
                
                // Get the dragged item info
                if (currentProject && currentProject.content && draggedIndex !== null) {
                    const mediaItem = currentProject.content[draggedIndex];
                    const projectId = currentProject.id;
                    
                    console.log('üóëÔ∏è Deleting media item:', mediaItem);
                    console.log('üóëÔ∏è From project:', projectId);
                    
                    // Call the deletion function (pass null as event since we don't have one)
                    deleteMediaItem(null, projectId, draggedIndex);
                } else {
                    console.error('‚ùå Missing project or draggedIndex for deletion');
                }
                
                cleanupDrag();
                return;
            }
            
            // Remove placeholder
            removeDropPlaceholder();
            
            // Find drop position
            const dropPosition = findClosestDropPosition(event.clientX, event.clientY);
            
        if (dropPosition) {
            console.log('‚úÖ Valid drop position found:', dropPosition);
            
            // Safety check for currentProject
            if (!currentProject || !currentProject.content) {
                console.error('‚ùå currentProject is null or missing content');
                cleanup();
                resetDragState();
                return;
            }
            
            console.log('üìã Original content length:', currentProject.content.length);
            console.log('üìã Dragged item:', currentProject.content[draggedIndex]);
                
                // Calculate the effective target position
                let targetIndex = dropPosition.index;
                
                // Only snap back if we're literally dropping in the exact same spot
                // AND we're not trying to insert between items (which can have the same index but different position)
                if (targetIndex === draggedIndex && dropPosition.side === 'same') {
                    console.log('‚ùå Exact same position drop - snapping back');
                    console.log('üîç Debug: draggedIndex =', draggedIndex, 'targetIndex =', targetIndex, 'side =', dropPosition.side);
                    console.log('üîç Current local state:', localProjectState ? localProjectState.content.map((item, idx) => `${idx}: ${item.alt || item.url.split('/').pop()}`) : 'null');
                    snapBackToOriginal();
                    cleanup();
                    resetDragState();
                    return;
                }
                
                // Additional safety check - if targetIndex is invalid, snap back
                if (targetIndex < 0 || targetIndex > currentProject.content.length) {
                    console.log('‚ùå Invalid target index - snapping back');
                    console.log('üîç Debug: targetIndex =', targetIndex, 'content length =', currentProject.content.length);
                    snapBackToOriginal();
                    cleanup();
                    resetDragState();
                    return;
                }
                
                // Log the drop decision for debugging
                console.log('‚úÖ Valid drop detected:', {
                    draggedIndex: draggedIndex,
                    targetIndex: targetIndex,
                    side: dropPosition.side,
                    willReorder: targetIndex !== draggedIndex
                });
                
                // Update local state immediately (instant feedback)
                updateLocalPositions(draggedIndex, targetIndex);
                
                // Update the UI using direct DOM manipulation (no re-render)
                if (currentProject) {
                    const viewerBody = document.getElementById('mediaViewerBody');
                    
                    // Get the actual DOM element that was dragged (it's currently hidden with .removed)
                    const actualDraggedDOMElement = draggedElement; 

                    // Remove it from its current position in the DOM
                    if (actualDraggedDOMElement && actualDraggedDOMElement.parentNode) {
                        actualDraggedDOMElement.parentNode.removeChild(actualDraggedDOMElement);
                    }

                    // Get all current media items in the DOM (excluding the one just removed)
                    const currentDOMMediaItems = Array.from(viewerBody.querySelectorAll('.media-item:not(.removed)'));

                    // Insert the dragged element at the new target position
                    if (targetIndex >= currentDOMMediaItems.length) {
                        viewerBody.appendChild(actualDraggedDOMElement);
            } else {
                        viewerBody.insertBefore(actualDraggedDOMElement, currentDOMMediaItems[targetIndex]);
                    }
                    
                    console.log('‚úÖ DOM reordered without re-render');
                } else {
                    console.error('‚ùå currentProject is null, cannot update UI');
                }
                
                // Queue the update for background sync (no immediate backend call)
                if (localProjectState) {
                    queuePositionUpdate(localProjectState.id, localProjectState.content);
                }
                
                // No need to reattach event listeners - they're already attached to the DOM elements
                console.log('‚úÖ Drag operation completed without re-attaching listeners');
            } else {
                console.log('‚ùå No valid drop position, snapping back');
                console.log('üîç Drop position:', dropPosition);
                console.log('üîç Dragged index:', draggedIndex);
                // Snap back to original position
                snapBackToOriginal();
            }
            
        // Always cleanup and reset
            cleanup();
        resetDragState();
        
        // Ensure all items are visible after drag operation
        document.querySelectorAll('.media-item.removed').forEach(el => {
            el.classList.remove('removed');
            el.style.opacity = '1';
        });
        }
        
        function resetDragState() {
            console.log('üîÑ Resetting drag state');
            isDragging = false;
            isDraggingToTrash = false;
            draggedElement = null;
            draggedIndex = null;
            draggedClone = null;
            currentProject = null;
            dragStartPosition = null;
            dragOffset = { x: 0, y: 0 };
            originalPosition = null;
            
            // CRITICAL: Ensure ALL items are visible
            document.querySelectorAll('.media-item.removed').forEach(el => {
                el.classList.remove('removed');
                el.style.opacity = '1';
            });
            
            // Remove any stuck visual elements
            removeDropPlaceholder();
            
            // Remove dragging class from modal
            const modal = document.querySelector('.media-viewer-modal');
            if (modal) {
                modal.classList.remove('dragging');
            }
            
            // Restore text selection
            document.body.style.userSelect = '';
            document.body.style.webkitUserSelect = '';
            document.body.style.mozUserSelect = '';
            document.body.style.msUserSelect = '';
            
            // Remove any stuck event listeners
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
            
            // Clear any timeout
            if (dragTimeout) {
                clearTimeout(dragTimeout);
                dragTimeout = null;
            }
            
            console.log('‚úÖ Drag state reset complete');
        }
        
        function updateDraggableStates(reorderMode) {
            const mediaItems = document.querySelectorAll('.media-item');
            mediaItems.forEach((item, index) => {
                if (reorderMode) {
                    item.setAttribute('draggable', 'true');
                    item.setAttribute('ondragstart', `handleMediaDragStart(event, ${index})`);
                } else {
                    item.setAttribute('draggable', 'false');
                    item.removeAttribute('ondragstart');
                }
                
                // Update mousedown handler
                item.setAttribute('onmousedown', `handleMouseDown(event, ${index})`);
            });
            
            console.log('‚úÖ Draggable states updated without re-rendering');
        }

        function reattachMediaEventListeners() {
            console.log('üîó Re-attaching media event listeners');
            
            // Force reset any stuck drag state first
            emergencyDragCleanup();
            
            const mediaItems = document.querySelectorAll('.media-item');
            console.log('üîó Found', mediaItems.length, 'media items in DOM');
            mediaItems.forEach((item, index) => {
                // Simply update the draggable attribute and event handlers without replacing the DOM element
                // This prevents the glitchy reload effect
                
                // Update draggable attribute
                if (isReorderMode) {
                    item.setAttribute('draggable', 'true');
                    item.setAttribute('ondragstart', `handleMediaDragStart(event, ${index})`);
                } else {
                    item.setAttribute('draggable', 'false');
                    item.removeAttribute('ondragstart');
                }
                
                // Update mousedown handler
                item.setAttribute('onmousedown', `handleMouseDown(event, ${index})`);
            });
            console.log('‚úÖ Event listeners re-attached to', mediaItems.length, 'media items');
        }
        
        function forceResetDragSystem() {
            console.log('üö® Force resetting entire drag system');
            emergencyDragCleanup();
            
            // Remove any stuck clones or placeholders
            document.querySelectorAll('.dragged').forEach(el => el.remove());
            document.querySelectorAll('.drop-indicator-line').forEach(el => el.remove());
            document.querySelectorAll('.removed').forEach(el => {
                el.classList.remove('removed');
                el.style.opacity = '1';
            });
            
            // Event listeners are already attached to DOM elements - no need to reattach
        }
        
        function snapBackToOriginal() {
            // Restore the original element
            draggedElement.classList.remove('removed');
            
            // Insert it back at the original position
            if (originalPosition.nextSibling) {
                originalPosition.parent.insertBefore(draggedElement, originalPosition.nextSibling);
            } else {
                originalPosition.parent.appendChild(draggedElement);
            }
        }
        
        function cleanup() {
            // Remove clone
            if (draggedClone) {
                draggedClone.remove();
                draggedClone = null;
            }
            
            // Reset variables
            draggedIndex = null;
            currentProject = null;
            draggedElement = null;
            isDragging = false;
            dragOffset = { x: 0, y: 0 };
            originalPosition = null;
        }
        
        function updateMediaViewerContent(project, skipDragUpdates = false) {
            const viewerBody = document.getElementById('mediaViewerBody');
            if (!viewerBody) return;
            
            // Use local state if available, otherwise fall back to project data
            const contentToRender = localProjectState ? localProjectState.content : project.content;
            
            console.log('üîÑ updateMediaViewerContent called with:', contentToRender.length, 'items');
            console.log('üîÑ skipDragUpdates:', skipDragUpdates, 'isDragging:', isDragging, 'isDraggingToTrash:', isDraggingToTrash);
            
            // Don't re-render if we're in the middle of a drag operation and skipDragUpdates is true
            if (skipDragUpdates && (isDragging || isDraggingToTrash)) {
                console.log('‚è≠Ô∏è Skipping re-render due to drag operation');
                return;
            }
            
        viewerBody.innerHTML = contentToRender
            .filter(item => item && item.type && (item.url || item.thumbnailUrl) && item.mediaId)
            .map((item, index) => {
            // Use thumbnail if available, otherwise use original
            const imageUrl = item.thumbnailUrl || item.url;
            // For click handler, prioritize HLS URL for videos, otherwise use actual media URL
            const clickUrl = item.type === 'video' ? (item.urls?.hls || item.url) : imageUrl;
            console.log(`üñºÔ∏è Gallery thumbnail ${index}: ${item.type} - Using URL: ${imageUrl} (thumbnailUrl: ${item.thumbnailUrl})`);
            console.log(`üîç Item URLs available:`, item.urls);
            console.log(`üîç HLS URL:`, item.urls?.hls);
            
            return `
                <div class="media-item ${isReorderMode ? 'reorder-mode' : ''}" 
                     data-index="${index}" 
                     data-media-id="${item.mediaId || ''}"
                     draggable="${isReorderMode ? 'true' : 'false'}"
                     ondragstart="${isReorderMode ? `handleMediaDragStart(event, ${index})` : ''}"
                     onmousedown="handleMouseDown(event, ${index})"
                     onclick="handleMediaClick(event, '${clickUrl}', '${item.type}', ${index}, '${project.id}')">
                        ${item.type === 'video' ? 
                            `<img src="${item.thumbnailUrl || item.url}" alt="${item.alt || 'Video'}" style="width: 100%; height: 100%; object-fit: contain; background: #1a1a1a;" 
                                  onload="cacheImage('${item.thumbnailUrl || item.url}', this)" 
                                  data-original="${item.url}"
                                  data-video="true"
                                  data-video-qualities='${item.videoQualities ? JSON.stringify(item.videoQualities) : ''}'>` :
                            `<img src="${imageUrl}" alt="${item.alt || 'Media'}" style="width: 100%; height: 100%; object-fit: contain; background: #1a1a1a;" 
                                  onload="cacheImage('${imageUrl}', this)" 
                                  data-original="${item.url}">`
                        }
                    ${item.type === 'video' ? '<div class="play-icon">‚ñ∂</div>' : ''}
                </div>
            `;
        }).join('');
        
        // Always re-attach event listeners after rendering new content
        if (!skipDragUpdates) {
            // Event listeners are already attached to DOM elements - no need to reattach
            console.log('‚úÖ Media viewer content updated without reattaching listeners');
        }
            
        }
        
        async function fetchProjects() {
            try {
                const response = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/projects');
                const data = await response.json();
                projects = data.projects || [];
                console.log('üìÅ Projects fetched from database:', projects);
                return projects;
            } catch (error) {
                console.error('‚ùå Error fetching projects:', error);
                return [];
            }
        }
        
        async function saveMediaOrder(projectId, newContent) {
            try {
                console.log('üíæ Saving media order for project:', projectId);
                console.log('üìù New content order:', newContent);
                
                // Use the new media-order endpoint to update individual media positions
                const response = await fetch(`/api/projects/${projectId}/media-order`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        mediaOrder: newContent.map((item, index) => ({
                            mediaId: item.mediaId,
                            position: index
                        }))
                    })
                });
                
                if (response.ok) {
                    console.log('‚úÖ Media order saved successfully!');
                    // Refresh the projects to ensure UI is in sync with database
                    await fetchProjects();
                } else {
                    const errorData = await response.json();
                    console.error('‚ùå Failed to save media order:', errorData.error);
                    alert('Failed to save media order: ' + errorData.error);
                }
            } catch (error) {
                console.error('‚ùå Error saving media order:', error);
                alert('Error saving media order: ' + error.message);
            }
        }
        
        // Reorder Mode Functions
        function toggleMediaReorderMode() {
            isReorderMode = !isReorderMode;
            const toggle = document.getElementById('reorderToggle');
            const viewerBody = document.getElementById('mediaViewerBody');
            const header = document.querySelector('.media-viewer-header');
            
            if (isReorderMode) {
                toggle.textContent = 'Exit Reorder';
                toggle.classList.add('active');
                viewerBody.classList.add('reorder-mode');
                
                // Add delete drop zone to header if it doesn't exist
                let deleteZone = document.getElementById('deleteDropZone');
                if (!deleteZone) {
                    const headerButtons = header.querySelector('div[style*="display: flex"]');
                    if (headerButtons) {
                        const deleteZoneHTML = `
                            <div class="delete-controls">
                                <div class="delete-drop-zone visible" id="deleteDropZone" 
                                     ondragover="handleDeleteDragOver(event)" 
                                     ondragenter="handleDeleteDragEnter(event)" 
                                     ondragleave="handleDeleteDragLeave(event)" 
                                     ondrop="handleDeleteDrop(event)">
                                    <div class="delete-icon">üóëÔ∏è</div>
                                    <div class="delete-text">Drop to Delete</div>
                                </div>
                                <button class="delete-all-btn" onclick="deleteAllMedia()" title="Delete All Media">
                                    üóëÔ∏è All
                                </button>
                            </div>
                        `;
                        headerButtons.insertAdjacentHTML('afterbegin', deleteZoneHTML);
                    }
                } else {
                    // Show existing delete zone
                    deleteZone.classList.add('visible');
                }
            } else {
                toggle.textContent = 'Reorder Mode';
                toggle.classList.remove('active');
                viewerBody.classList.remove('reorder-mode');
                
                // Hide delete drop zone instead of removing it
                const deleteZone = document.getElementById('deleteDropZone');
                if (deleteZone) {
                    deleteZone.classList.remove('visible');
                }
            }
            
            // Update draggable states without re-rendering content
            // Use local state if available, otherwise fall back to project data
            const projectToUse = localProjectState ? 
                projects.find(p => p.id === localProjectState.id) : 
                projects.find(p => p.title === viewerModal.querySelector('h3').textContent);
                
            if (projectToUse) {
                // Just update the draggable attributes without re-rendering
                updateDraggableStates(isReorderMode);
            }
        }
        
        function handleMediaClick(event, url, type, index, projectId) {
            // Prevent fullscreen if in reorder mode
            if (isReorderMode) {
                event.preventDefault();
                event.stopPropagation();
                return;
            }
            
            console.log(`üñ±Ô∏è Media clicked - URL: ${url}, Type: ${type}, Index: ${index}, Project: ${projectId}`);
            console.log('üñ±Ô∏è Available projects:', projects.map(p => ({ id: p.id, title: p.title, contentCount: p.content?.length })));
            
            // Only open fullscreen if not in reorder mode
            showFullscreen(url, type, index, projectId);
        }
        
        // Media drag functions
        function handleMediaDragStart(event, mediaIndex) {
            event.dataTransfer.setData('text/plain', mediaIndex);
            
            // Get project ID from the modal title or current project
            const modal = event.target.closest('.media-viewer-modal');
            const projectTitle = modal.querySelector('h3').textContent;
            const project = projects.find(p => p.title === projectTitle);
            if (project) {
                event.dataTransfer.setData('application/json', project.id);
            }
            
            event.dataTransfer.effectAllowed = 'move';
            console.log('üéØ Starting drag of media item at index:', mediaIndex);
            
            // Create a custom drag image to prevent ghost issues
            const dragImage = document.createElement('div');
            dragImage.innerHTML = 'üóëÔ∏è';
            dragImage.style.position = 'absolute';
            dragImage.style.top = '-1000px';
            dragImage.style.fontSize = '24px';
            dragImage.style.pointerEvents = 'none';
            dragImage.style.opacity = '0.8';
            document.body.appendChild(dragImage);
            
            try {
                event.dataTransfer.setDragImage(dragImage, 12, 12);
            } catch (e) {
                console.log('Could not set custom drag image:', e);
            }
            
            // Clean up the drag image after drag ends
            const cleanupDragImage = () => {
                if (document.body.contains(dragImage)) {
                    document.body.removeChild(dragImage);
                }
            };
            
            // Set up cleanup on drag end
            document.addEventListener('dragend', cleanupDragImage, { once: true });
            document.addEventListener('drop', cleanupDragImage, { once: true });
        }
        
        // Delete drop zone functions
        function handleDeleteDragOver(event) {
            event.preventDefault();
            event.stopPropagation();
            event.dataTransfer.dropEffect = 'move';
            const deleteZone = document.getElementById('deleteDropZone');
            if (deleteZone) {
                deleteZone.classList.add('drag-over');
                console.log('üéØ Entering delete zone');
            }
        }
        
        function handleDeleteDragEnter(event) {
            event.preventDefault();
            event.stopPropagation();
            const deleteZone = document.getElementById('deleteDropZone');
            if (deleteZone) {
                deleteZone.classList.add('drag-over');
                console.log('üéØ Entering delete zone');
            }
        }
        
        function handleDeleteDragLeave(event) {
            event.preventDefault();
            event.stopPropagation();
            const deleteZone = document.getElementById('deleteDropZone');
            if (deleteZone && !deleteZone.contains(event.relatedTarget)) {
                deleteZone.classList.remove('drag-over');
                console.log('üéØ Leaving delete zone');
            }
        }
        
        function handleDeleteDrop(event) {
            event.preventDefault();
            event.stopPropagation();
            
            const deleteZone = document.getElementById('deleteDropZone');
            if (deleteZone) {
                deleteZone.classList.remove('drag-over');
            }
            
            const mediaIndex = parseInt(event.dataTransfer.getData('text/plain'));
            const projectId = event.dataTransfer.getData('application/json');
            
            console.log('üóëÔ∏è Delete drop triggered:', { mediaIndex, projectId });
            
            if (isNaN(mediaIndex) || !projectId) {
                console.error('‚ùå Invalid drop data');
                return;
            }
            
            // Get the project
            const project = projects.find(p => p.id === projectId);
            if (!project || !project.content || !project.content[mediaIndex]) {
                console.error('‚ùå Project or media item not found');
                return;
            }
            
            // Show visual feedback
            if (deleteZone) {
                deleteZone.style.background = 'rgba(255, 68, 68, 0.5)';
                deleteZone.style.transform = 'scale(1.1)';
            }
            
            const mediaItem = project.content[mediaIndex];
            console.log('üóëÔ∏è Deleting media item:', mediaItem);
            
            // Delete the media item
            deleteMediaItem(projectId, mediaIndex, mediaItem);
            
            // Reset visual feedback after a delay
            setTimeout(() => {
                if (deleteZone) {
                    deleteZone.style.background = '';
                    deleteZone.style.transform = '';
                }
            }, 300);
        }
        
        
        async function deleteMediaItem(event, projectId, mediaIndex) {
            // Handle case where event is null (called from drag-to-delete)
            if (event) {
            event.preventDefault();
            event.stopPropagation();
            }
            
            if (!confirm('Are you sure you want to delete this media item?')) {
                return;
            }
            
            try {
                // Find the project and get the media item to delete
                const project = projects.find(p => p.id === projectId);
                if (!project || !project.content[mediaIndex]) {
                    console.error('‚ùå Media item not found');
                    return;
                }
                
                const mediaItem = project.content[mediaIndex];
                
                // Remove from the content array
                project.content.splice(mediaIndex, 1);
                
                // Update local state immediately
                if (localProjectState && localProjectState.id === projectId) {
                    localProjectState.content = [...project.content];
                    console.log('üîÑ Updated local state after deletion');
                }
                
                // Update the UI immediately
                updateMediaViewerContent(project);
                
                // Update project card count immediately
                updateProjectCardCount(projectId, project.content.length);
                
                // Save the updated project to the server
                const response = await fetch(`/api/projects/${projectId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: project.content.map(item => ({
                            type: item.type,
                            url: item.url,
                            mediaId: item.mediaId,
                            alt: item.alt
                        }))
                    })
                });
                
                if (response.ok) {
                    console.log('‚úÖ Media item deleted successfully');
                    
                    // Also delete from S3 and DynamoDB media table
                    if (mediaItem.url) {
                        try {
                            // Extract S3 key from URL
                            // URL format: https://bucket.s3.amazonaws.com/projects/projectId/media/filename
                            const url = new URL(mediaItem.url);
                            const s3Key = decodeURIComponent(url.pathname.substring(1)); // Remove leading slash and decode URL
                            
                            console.log('üóëÔ∏è Deleting from S3 using mediaId:', mediaItem.mediaId);
                            
                            // Delete from S3 using mediaId instead of s3Key
                            await fetch(`/api/media/${mediaItem.mediaId}`, {
                                method: 'DELETE'
                            });
                            
                            console.log('‚úÖ Successfully deleted from S3');
                            
                            // Also delete the media record from DynamoDB using s3Key
                            console.log('üóëÔ∏è Deleting media record from DynamoDB for s3Key:', s3Key);
                            await fetch(`/api/media-record/${encodeURIComponent(s3Key)}`, {
                                method: 'DELETE'
                            });
                            console.log('‚úÖ Successfully deleted media record from DynamoDB');
                            
                        } catch (s3Error) {
                            console.warn('‚ö†Ô∏è Failed to delete from S3 or DynamoDB:', s3Error);
                        }
                    }
                    
                    // Update the main projects array locally without reloading
                    const projectIndex = projects.findIndex(p => p.id === projectId);
                    if (projectIndex !== -1) {
                        projects[projectIndex].content = [...project.content];
                        console.log('üîÑ Updated main projects array locally');
                    }
                } else {
                    console.error('‚ùå Failed to delete media item');
                }
            } catch (error) {
                console.error('‚ùå Error deleting media item:', error);
            }
        }

        document.getElementById('saveBtn').addEventListener('click', saveProject);
        
        // Tab switching functionality
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + 'TabContent').classList.add('active');
            
            // Add active class to selected tab button
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // If switching to grid tab, initialize grid editor
            if (tabName === 'grid') {
                setTimeout(() => {
                    generateGrid();
                    renderLivePreview();
                }, 100);
            }
        }
        
        // Grid Layout Editor functionality
        document.getElementById('applyGridBtn').addEventListener('click', applyGridSettings);
        
        
        function deleteProject(projectId) {
            if (!confirm('Are you sure you want to delete this project? This action cannot be undone.')) {
                return;
            }
            
            fetch(`/api/projects/${projectId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    loadProjects();
                    alert('Project deleted successfully');
                } else {
                    alert('Failed to delete project');
                }
            })
            .catch(error => {
                console.error('Error deleting project:', error);
                alert('Error deleting project');
            });
        }
        
        // Project Drag and Drop Variables (like media items)
        let projectDraggedIndex = null;
        let projectDraggedElement = null;
        let projectDraggedClone = null;
        let projectDropPlaceholder = null;
        let projectIsDragging = false;
        let projectDragOffset = { x: 0, y: 0 };
        let projectOriginalPosition = null;
        
        function handleProjectMouseDown(event, index) {
            console.log('üñ±Ô∏è Project mouse down triggered!', { isProjectReorderMode, index });
            
            if (!isProjectReorderMode) {
                console.log('‚ùå Not in reorder mode, ignoring');
                return;
            }
            
            event.preventDefault();
            event.stopPropagation();
            
            console.log('‚úÖ Starting project drag for index:', index);
            projectDraggedIndex = index;
            projectDraggedElement = event.target.closest('.project-card');
            
            // Calculate offset from mouse to element
            const rect = projectDraggedElement.getBoundingClientRect();
            projectDragOffset.x = event.clientX - rect.left;
            projectDragOffset.y = event.clientY - rect.top;
            
            // Store original position for snap-back
            projectOriginalPosition = {
                element: projectDraggedElement,
                parent: projectDraggedElement.parentNode,
                nextSibling: projectDraggedElement.nextSibling
            };
            
            // Create ghost clone that follows cursor
            projectDraggedClone = projectDraggedElement.cloneNode(true);
            projectDraggedClone.classList.add('dragged');
            projectDraggedClone.style.left = event.clientX - projectDragOffset.x + 'px';
            projectDraggedClone.style.top = event.clientY - projectDragOffset.y + 'px';
            projectDraggedClone.style.width = rect.width + 'px';
            projectDraggedClone.style.height = rect.height + 'px';
            
            document.body.appendChild(projectDraggedClone);
            
            // Completely remove original element from the grid
            projectDraggedElement.classList.add('removed');
            
            projectIsDragging = true;
            
            // Add event listeners
            document.addEventListener('mousemove', handleProjectMouseMove);
            document.addEventListener('mouseup', handleProjectMouseUp);
        }
        
        function handleProjectMouseMove(event) {
            if (!projectIsDragging || !projectDraggedClone) return;
            
            // Update clone position to follow cursor
            projectDraggedClone.style.left = event.clientX - projectDragOffset.x + 'px';
            projectDraggedClone.style.top = event.clientY - projectDragOffset.y + 'px';
            
            // Find the closest drop position
            const dropPosition = findClosestProjectDropPosition(event.clientX, event.clientY);
            if (dropPosition) {
                createProjectDropPlaceholder(dropPosition);
            } else {
                // Remove placeholder if outside valid drop zones
                removeProjectDropPlaceholder();
            }
        }
        
        function findClosestProjectDropPosition(mouseX, mouseY) {
            const projectCards = document.querySelectorAll('.project-card:not(.removed)');
            let closestDistance = Infinity;
            let closestPosition = null;
            
            // Only show drop indicator if mouse is VERY close to a project card
            const DROP_TOLERANCE = 50; // pixels - must be within 50px of a card
            
            projectCards.forEach((card, index) => {
                const rect = card.getBoundingClientRect();
                const currentIndex = parseInt(card.dataset.index);
                
                // Adjust index if we're dragging an item that comes before this one
                let adjustedIndex = currentIndex;
                if (projectDraggedIndex !== null && projectDraggedIndex < currentIndex) {
                    adjustedIndex = currentIndex - 1;
                }
                
                // Check if mouse is close to the LEFT side of the card
                if (mouseX >= rect.left - DROP_TOLERANCE && mouseX <= rect.left + DROP_TOLERANCE && 
                    mouseY >= rect.top && mouseY <= rect.bottom) {
                    const distance = Math.abs(mouseX - rect.left);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPosition = {
                            index: adjustedIndex,
                            side: 'left',
                            rect: rect,
                            element: card
                        };
                    }
                }
                // Check if mouse is close to the RIGHT side of the card
                else if (mouseX >= rect.right - DROP_TOLERANCE && mouseX <= rect.right + DROP_TOLERANCE && 
                         mouseY >= rect.top && mouseY <= rect.bottom) {
                    const distance = Math.abs(mouseX - rect.right);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPosition = {
                            index: adjustedIndex + 1,
                            side: 'right',
                            rect: rect,
                            element: card
                        };
                    }
                }
                // Check if mouse is close to the TOP of the card
                else if (mouseY >= rect.top - DROP_TOLERANCE && mouseY <= rect.top + DROP_TOLERANCE && 
                         mouseX >= rect.left && mouseX <= rect.right) {
                    const distance = Math.abs(mouseY - rect.top);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPosition = {
                            index: adjustedIndex,
                            side: 'above',
                            rect: rect,
                            element: card
                        };
                    }
                }
                // Check if mouse is close to the BOTTOM of the card
                else if (mouseY >= rect.bottom - DROP_TOLERANCE && mouseY <= rect.bottom + DROP_TOLERANCE && 
                         mouseX >= rect.left && mouseX <= rect.right) {
                    const distance = Math.abs(mouseY - rect.bottom);
                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPosition = {
                            index: adjustedIndex + 1,
                            side: 'below',
                            rect: rect,
                            element: card
                        };
                    }
                }
            });
            
            return closestPosition;
        }
        
        function createProjectDropPlaceholder(position) {
            // Remove existing indicator
            removeProjectDropPlaceholder();
            
            if (!position) return;
            
            // Create vertical line indicator
            projectDropPlaceholder = document.createElement('div');
            projectDropPlaceholder.className = 'drop-indicator-line';
            
            // Position the line exactly next to the project card
            const rect = position.rect;
            const projectsList = document.getElementById('projectsList');
            const containerRect = projectsList.getBoundingClientRect();
            
            // Calculate position relative to the projects list
            const relativeLeft = rect.left - containerRect.left;
            const relativeTop = rect.top - containerRect.top;
            
            if (position.side === 'left') {
                // Vertical line to the LEFT of the card
                projectDropPlaceholder.style.left = (relativeLeft - 3) + 'px';
                projectDropPlaceholder.style.top = relativeTop + 'px';
                projectDropPlaceholder.style.width = '3px';
                projectDropPlaceholder.style.height = rect.height + 'px';
                projectDropPlaceholder.style.transform = 'none';
            } else if (position.side === 'right') {
                // Vertical line to the RIGHT of the card
                projectDropPlaceholder.style.left = (relativeLeft + rect.width + 3) + 'px';
                projectDropPlaceholder.style.top = relativeTop + 'px';
                projectDropPlaceholder.style.width = '3px';
                projectDropPlaceholder.style.height = rect.height + 'px';
                projectDropPlaceholder.style.transform = 'none';
            } else if (position.side === 'above') {
                // Horizontal line ABOVE the card
                projectDropPlaceholder.style.left = relativeLeft + 'px';
                projectDropPlaceholder.style.top = (relativeTop - 3) + 'px';
                projectDropPlaceholder.style.width = rect.width + 'px';
                projectDropPlaceholder.style.height = '3px';
                projectDropPlaceholder.style.transform = 'none';
            } else if (position.side === 'below') {
                // Horizontal line BELOW the card
                projectDropPlaceholder.style.left = relativeLeft + 'px';
                projectDropPlaceholder.style.top = (relativeTop + rect.height + 3) + 'px';
                projectDropPlaceholder.style.width = rect.width + 'px';
                projectDropPlaceholder.style.height = '3px';
                projectDropPlaceholder.style.transform = 'none';
            }
            
            // Append to projects list
            projectsList.appendChild(projectDropPlaceholder);
        }
        
        function removeProjectDropPlaceholder() {
            if (projectDropPlaceholder) {
                projectDropPlaceholder.remove();
                projectDropPlaceholder = null;
            }
        }
        
        function handleProjectMouseUp(event) {
            if (!projectIsDragging) return;
            
            // Remove event listeners
            document.removeEventListener('mousemove', handleProjectMouseMove);
            document.removeEventListener('mouseup', handleProjectMouseUp);
            
            // Remove placeholder
            removeProjectDropPlaceholder();
            
            // Find drop position
            const dropPosition = findClosestProjectDropPosition(event.clientX, event.clientY);
            
            if (dropPosition && dropPosition.index !== projectDraggedIndex) {
                // Valid drop - reorder the projects
                const newOrder = projects.map(p => ({ id: p.id }));
                const draggedProject = newOrder.splice(projectDraggedIndex, 1)[0];
                newOrder.splice(dropPosition.index, 0, draggedProject);
                
                // Save the new order to the server
                reorderProjectsAPI(newOrder);
            } else {
                // Snap back to original position
                snapBackProjectToOriginal();
            }
            
            // Cleanup
            cleanupProjectDrag();
        }
        
        function snapBackProjectToOriginal() {
            // Restore the original element
            projectDraggedElement.classList.remove('removed');
        }
        
        function cleanupProjectDrag() {
            // Remove clone
            if (projectDraggedClone) {
                projectDraggedClone.remove();
                projectDraggedClone = null;
            }
            
            // Reset variables
            projectDraggedIndex = null;
            projectDraggedElement = null;
            projectIsDragging = false;
            projectDragOffset = { x: 0, y: 0 };
            projectOriginalPosition = null;
        }
        
        // Grid Layout Functions
        function applyGridSettings() {
            const width = parseInt(document.getElementById('gridWidth').value);
            const height = parseInt(document.getElementById('gridHeight').value);
            const sectionTitle = document.getElementById('sectionTitle').value;
            
            // Clear ALL existing projects from grid and move them back to unused
            const projectsMoved = Object.keys(gridLayout.positions).length;
            gridLayout.positions = {}; // Clear all positions
            
            // Update grid dimensions
            gridLayout.width = width;
            gridLayout.height = height;
            gridLayout.sectionTitle = sectionTitle;
            
            console.log(`üìê Applied new grid dimensions: ${width}x${height}. Section title: "${sectionTitle}". Moved ${projectsMoved} projects back to unused.`);
            
            generateGrid();
            // Update live preview
            renderLivePreview();
        }
        
        function generateGrid() {
            const gridContainer = document.getElementById('gridContainer');
            const totalPositions = gridLayout.width * gridLayout.height;
            
            // Set grid template columns
            gridContainer.style.gridTemplateColumns = `repeat(${gridLayout.width}, 120px)`;
            
            // Clear existing grid
            gridContainer.innerHTML = '';
            
            // Generate grid positions
            for (let i = 0; i < totalPositions; i++) {
                const gridPosition = document.createElement('div');
                gridPosition.className = 'grid-position';
                gridPosition.dataset.position = i;
                
                // Add position number
                const positionNumber = document.createElement('div');
                positionNumber.className = 'grid-position-number';
                positionNumber.textContent = i;
                gridPosition.appendChild(positionNumber);
                
                // Check if this position has a project (filter out grid_layout)
                if (gridLayout.positions[i] && gridLayout.positions[i] !== 'grid_layout') {
                    const project = projects.find(p => p.id === gridLayout.positions[i]);
                    if (project) {
                        gridPosition.classList.add('occupied');
                        gridPosition.innerHTML = `
                            <div class="grid-position-number">${i}</div>
                            <div class="project-in-grid" data-project-id="${project.id}" data-position="${i}" draggable="true" ondragstart="handleGridProjectDragStart(event)">
                                ${project.coverImage ? 
                                    `<img src="${project.coverImage}" alt="${project.title}">` :
                                    '<div style="background: #444; color: #888; display: flex; align-items: center; justify-content: center; font-size: 12px;">No Image</div>'
                                }
                                <div class="project-title">${project.title}</div>
                                <button class="remove-from-grid" onclick="removeProjectFromGrid(${i})" title="Remove from grid">√ó</button>
                            </div>
                        `;
                    }
                }
                
                // Add drag and drop events
                gridPosition.addEventListener('dragover', handleGridDragOver);
                gridPosition.addEventListener('drop', handleGridDrop);
                
                gridContainer.appendChild(gridPosition);
            }
            
            updateUnusedProjectsBin();
            // Update live preview
            renderLivePreview();
        }
        
        function updateUnusedProjectsBin() {
            const unusedBin = document.getElementById('unusedProjectsBin');
            const usedProjectIds = Object.values(gridLayout.positions);
            const unusedProjects = projects.filter(p => p.id && !usedProjectIds.includes(p.id));
            
            console.log('üì¶ Updating unused projects bin:', unusedProjects.length, 'projects');
            console.log('üîç Used project IDs:', usedProjectIds);
            console.log('üìã All projects:', projects.map(p => ({ id: p.id, title: p.title })));
            
            unusedBin.innerHTML = '';
            
            unusedProjects.forEach(project => {
                if (!project.id) {
                    console.warn('‚ö†Ô∏è Project missing ID:', project);
                    return;
                }
                
                const unusedProject = document.createElement('div');
                unusedProject.className = 'unused-project';
                unusedProject.draggable = true;
                unusedProject.dataset.projectId = project.id;
                
                unusedProject.innerHTML = `
                    ${project.coverImage ? 
                        `<img src="${project.coverImage}" alt="${project.title}">` :
                        '<div style="background: #444; color: #888; display: flex; align-items: center; justify-content: center; font-size: 10px;">No Image</div>'
                    }
                    <div class="project-title">${project.title}</div>
                `;
                
                unusedProject.addEventListener('dragstart', (e) => {
                    console.log('üñ±Ô∏è Drag start for project:', project.id, project.title);
                    e.dataTransfer.setData('text/plain', project.id);
                });
                
                unusedBin.appendChild(unusedProject);
            });
        }
        
        function handleGridDragOver(e) {
            e.preventDefault();
            e.target.classList.add('drag-over');
        }
        
        function handleGridProjectDragStart(e) {
            // Find the draggable element (might be a child element that was clicked)
            let draggableElement = e.target;
            while (draggableElement && !draggableElement.dataset.projectId) {
                draggableElement = draggableElement.parentElement;
            }
            
            if (!draggableElement) {
                console.error('‚ùå Could not find draggable element with project data');
                return;
            }
            
            const projectId = draggableElement.dataset.projectId;
            const position = draggableElement.dataset.position;
            
            console.log('üöÄ Started dragging grid project:', projectId, 'from position:', position);
            console.log('üöÄ Draggable element:', draggableElement);
            
            if (!projectId || !position) {
                console.error('‚ùå Missing project data:', { projectId, position });
                return;
            }
            
            e.dataTransfer.setData('text/plain', projectId);
            e.dataTransfer.setData('application/json', JSON.stringify({ type: 'grid-project', position: position }));
        }

        function handleGridDrop(e) {
            e.preventDefault();
            e.target.classList.remove('drag-over');
            
            const projectId = e.dataTransfer.getData('text/plain');
            const dragData = e.dataTransfer.getData('application/json');
            
            // Find the grid position element (might be a child element that was clicked)
            let gridPositionElement = e.target;
            while (gridPositionElement && !gridPositionElement.dataset.position) {
                gridPositionElement = gridPositionElement.parentElement;
            }
            
            if (!gridPositionElement || !gridPositionElement.dataset.position) {
                console.error('‚ùå Could not find grid position element');
                return;
            }
            
            const position = parseInt(gridPositionElement.dataset.position);
            
            console.log('üéØ Dropping project:', projectId, 'at position:', position);
            console.log('üéØ Drag data:', dragData);
            console.log('üéØ Drop target:', e.target);
            console.log('üéØ Grid position element:', gridPositionElement);
            
            if (!projectId || projectId === 'undefined') {
                console.error('‚ùå Invalid project ID:', projectId);
                return;
            }

            let dragInfo = null;
            try {
                dragInfo = JSON.parse(dragData);
            } catch (e) {
                // Handle old format or missing data
            }

            // Check if we're dragging a grid project (swapping) or unused project
            if (dragInfo && dragInfo.type === 'grid-project') {
                // This is a swap operation
                const sourcePosition = parseInt(dragInfo.position);
                const targetProjectId = gridLayout.positions[position];
                
                console.log('üîÑ Swapping projects:', {
                    source: { position: sourcePosition, project: projectId },
                    target: { position: position, project: targetProjectId }
                });
                
                // Swap the projects
                if (targetProjectId) {
                    // Both positions occupied - swap them
                    gridLayout.positions[sourcePosition] = targetProjectId;
                    gridLayout.positions[position] = projectId;
                } else {
                    // Target is empty - just move the project
                    delete gridLayout.positions[sourcePosition];
                    gridLayout.positions[position] = projectId;
                }
            } else {
                // This is dragging from unused projects
                // Remove project from any existing position
                Object.keys(gridLayout.positions).forEach(pos => {
                    if (gridLayout.positions[pos] === projectId) {
                        delete gridLayout.positions[pos];
                    }
                });
                
                // Handle drop on occupied position
                if (gridLayout.positions[position]) {
                    // Target is occupied - remove the existing project (it goes back to unused)
                    delete gridLayout.positions[position];
                }
                
                // Add project to new position
                gridLayout.positions[position] = projectId;
            }
            
            console.log('üìê Updated grid layout:', gridLayout);
            
            generateGrid();
            // Update live preview
            renderLivePreview();
            saveGridLayout();
        }
        
        function handleUnusedProjectDragStart(e) {
            e.dataTransfer.setData('text/plain', e.target.dataset.projectId);
        }
        
        function removeProjectFromGrid(position) {
            delete gridLayout.positions[position];
            generateGrid();
            // Update live preview
            renderLivePreview();
            saveGridLayout();
        }
        
        async function loadGridLayout() {
            try {
                const response = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/grid-layout');
                const data = await response.json();
                
                if (data.success && data.layout) {
                    gridLayout = data.layout;
                    console.log('‚úÖ Grid layout loaded:', gridLayout);
                    
                    // Update the input fields
                    document.getElementById('gridWidth').value = gridLayout.width;
                    document.getElementById('gridHeight').value = gridLayout.height;
                    document.getElementById('sectionTitle').value = gridLayout.sectionTitle || 'Our Work';
                }
            } catch (error) {
                console.error('Failed to load grid layout:', error);
            }
        }
        
        async function saveGridLayout() {
            try {
                console.log('üíæ Attempting to save grid layout:', gridLayout);
                
                const response = await fetch('https://o7jiy71lw3.execute-api.us-east-1.amazonaws.com/prod/api/grid-layout', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(gridLayout)
                });
                
                console.log('üì° Save response status:', response.status);
                
                if (response.ok) {
                    const result = await response.json();
                    console.log('‚úÖ Grid layout saved successfully:', result);
                    // Refresh the projects to ensure we have the latest data
                    await loadProjects();
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå Save failed with status:', response.status, 'Error:', errorText);
                    throw new Error(`Failed to save grid layout: ${response.status} ${errorText}`);
                }
            } catch (error) {
                console.error('‚ùå Failed to save grid layout:', error);
                alert(`Failed to save grid layout: ${error.message}`);
            }
        }
        
        // Initialize HLS player for seamless adaptive streaming
        function initializeHLSPlayer(video, hlsUrl, mediaIndex) {
            if (typeof Hls === 'undefined') {
                console.log('‚ö†Ô∏è HLS.js not available, falling back to regular video');
                return false;
            }
            
            if (video.canPlayType('application/vnd.apple.mpegurl')) {
                // Safari supports HLS natively
                console.log('üçé Using native HLS support');
                video.src = hlsUrl;
                return true;
            } else if (Hls.isSupported()) {
                // Use HLS.js for other browsers
                console.log('üé¨ Using HLS.js for adaptive streaming');
                const hls = new Hls({
                    lowLatencyMode: false,
                    enableWorker: true,
                    startLevel: 0, // Start with lowest quality
                    maxBufferLength: 30,
                    maxMaxBufferLength: 60
                });
                
                hls.loadSource(hlsUrl);
                hls.attachMedia(video);
                
                // Store HLS instance for quality control
                video.hlsInstance = hls;
                
                // Update quality indicator when level changes
                hls.on(Hls.Events.LEVEL_SWITCHED, (event, data) => {
                    const level = hls.levels[data.level];
                    const qualityName = level ? `${level.height}p` : 'Auto';
                    updateQualityUI(mediaIndex, qualityName);
                });
                
                return true;
            } else {
                console.log('‚ö†Ô∏è HLS not supported in this browser');
                return false;
            }
        }
        
        // Change HLS video quality manually
        function changeHLSVideoQuality(selector, mediaIndex) {
            const selectedLevel = parseInt(selector.value);
            const video = document.getElementById(`main-video-${mediaIndex}`);
            
            if (video.hlsInstance) {
                video.hlsInstance.currentLevel = selectedLevel;
                const level = video.hlsInstance.levels[selectedLevel];
                const qualityName = level ? `${level.height}p` : 'Auto';
                updateQualityUI(mediaIndex, qualityName);
                console.log(`üé¨ Manually switched HLS quality to: ${qualityName}`);
            }
        }
        
        // Toggle download menu
        function toggleDownloadMenu(mediaIndex) {
            const menu = document.getElementById(`download-menu-${mediaIndex}`);
            if (menu) {
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        // Close download menus when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('[onclick*="toggleDownloadMenu"]')) {
                document.querySelectorAll('[id^="download-menu-"]').forEach(menu => {
                    menu.style.display = 'none';
                });
            }
        });
    </script>
</body>
</html>